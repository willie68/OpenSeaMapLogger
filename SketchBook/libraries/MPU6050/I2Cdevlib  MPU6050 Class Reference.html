<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>I2Cdevlib: MPU6050 Class Reference</title> <style type="text/css" style="display:none">.tabs,.tabs2,.tabs3{background-image:url('http://www.i2cdevlib.com/docs/html/tab_b.png');width:100%;z-index:101;font-size:13px;}.tabs2{font-size:10px;}.tabs3{font-size:9px;}.tablist{margin:0;padding:0;display:table;}.tablist li{float:left;display:table-cell;background-image:url('http://www.i2cdevlib.com/docs/html/tab_b.png');line-height:36px;list-style:none;}.tablist a{display:block;padding:0 20px;font-weight:bold;background-image:url('http://www.i2cdevlib.com/docs/html/tab_s.png');background-repeat:no-repeat;background-position:right;color:#283A5D;text-shadow:0px 1px 1px rgba(255,255,255,0.9);text-decoration:none;outline:none;}.tabs3 .tablist a{padding:0 10px;}.tablist a:hover{background-image:url('http://www.i2cdevlib.com/docs/html/tab_h.png');background-repeat:repeat-x;color:#fff;text-shadow:0px 1px 1px rgba(0,0,0,1.0);text-decoration:none;}.tablist li.current a{background-image:url('http://www.i2cdevlib.com/docs/html/tab_a.png');background-repeat:repeat-x;color:#fff;text-shadow:0px 1px 1px rgba(0,0,0,1.0);}
</style>
<style type="text/css" style="display:none">/**/body,table,div,p,dl{font-family:Lucida Grande,Verdana,Geneva,Arial,sans-serif;font-size:12px;}/**/h1{font-size:150%;}.title{font-size:150%;font-weight:bold;margin:10px 2px;}h2{font-size:120%;}h3{font-size:100%;}dt{font-weight:bold;}div.multicol{-moz-column-gap:1em;-webkit-column-gap:1em;-moz-column-count:3;-webkit-column-count:3;}p.startli,p.startdd,p.starttd{margin-top:2px;}p.endli{margin-bottom:0px;}p.enddd{margin-bottom:4px;}p.endtd{margin-bottom:2px;}/**/caption{font-weight:bold;}span.legend{font-size:70%;text-align:center;}h3.version{font-size:90%;text-align:center;}div.qindex,div.navtab{background-color:#EBEFF6;border:1px solid #A3B4D7;text-align:center;margin:2px;padding:2px;}div.qindex,div.navpath{width:100%;line-height:140%;}div.navtab{margin-right:15px;}/**/a{color:#3D578C;font-weight:normal;text-decoration:none;}.contents a:visited{color:#4665A2;}a:hover{text-decoration:underline;}a.qindex{font-weight:bold;}a.qindexHL{font-weight:bold;background-color:#9CAFD4;color:#ffffff;border:1px double #869DCA;}.contents a.qindexHL:visited{color:#ffffff;}a.el{font-weight:bold;}a.elRef{}a.code{color:#4665A2;}a.codeRef{color:#4665A2;}/**/dl.el{margin-left:-1cm;}.fragment{font-family:monospace,fixed;font-size:105%;}pre.fragment{border:1px solid #C4CFE5;background-color:#FBFCFD;padding:4px 6px;margin:4px 8px 4px 2px;overflow:auto;word-wrap:break-word;font-size:9pt;line-height:125%;}div.ah{background-color:black;font-weight:bold;color:#ffffff;margin-bottom:3px;margin-top:3px;padding:0.2em;border:solid thin #333;border-radius:0.5em;-webkit-border-radius:.5em;-moz-border-radius:.5em;box-shadow:2px 2px 3px #999;-webkit-box-shadow:2px 2px 3px #999;-moz-box-shadow:rgba(0,0,0,0.15) 2px 2px 2px;background-image:-webkit-gradient(linear,left top,left bottom,from(#eee),to(#000),color-stop(0.3,#444));background-image:-moz-linear-gradient(center top,#eee 0%,#444 40%,#000);}div.groupHeader{margin-left:16px;margin-top:12px;font-weight:bold;}div.groupText{margin-left:16px;font-style:italic;}body{background:white;color:black;margin:0;}div.contents{margin-top:10px;margin-left:10px;margin-right:5px;}td.indexkey{background-color:#EBEFF6;font-weight:bold;border:1px solid #C4CFE5;margin:2px 0px 2px 0;padding:2px 10px;}td.indexvalue{background-color:#EBEFF6;border:1px solid #C4CFE5;padding:2px 10px;margin:2px 0px;}tr.memlist{background-color:#EEF1F7;}p.formulaDsp{text-align:center;}img.formulaDsp{}img.formulaInl{vertical-align:middle;}div.center{text-align:center;margin-top:0px;margin-bottom:0px;padding:0px;}div.center img{border:0px;}address.footer{text-align:right;padding-right:12px;}img.footer{border:0px;vertical-align:middle;}/**/ span.keyword{color:#008000}span.keywordtype{color:#604020}span.keywordflow{color:#e08000}span.comment{color:#800000}span.preprocessor{color:#806020}span.stringliteral{color:#002080}span.charliteral{color:#008080}span.vhdldigit{color:#ff00ff}span.vhdlchar{color:#000000}span.vhdlkeyword{color:#700070}span.vhdllogic{color:#ff0000}/**/  /**/td.tiny{font-size:75%;}.dirtab{padding:4px;border-collapse:collapse;border:1px solid #A3B4D7;}th.dirtab{background:#EBEFF6;font-weight:bold;}hr{height:0px;border:none;border-top:1px solid #4A6AAA;}hr.footer{height:1px;}/**/table.memberdecls{border-spacing:0px;padding:0px;}.mdescLeft,.mdescRight,.memItemLeft,.memItemRight,.memTemplItemLeft,.memTemplItemRight,.memTemplParams{background-color:#F9FAFC;border:none;margin:4px;padding:1px 0 0 8px;}.mdescLeft,.mdescRight{padding:0px 8px 4px 8px;color:#555;}.memItemLeft,.memItemRight,.memTemplParams{border-top:1px solid #C4CFE5;}.memItemLeft,.memTemplItemLeft{white-space:nowrap;}.memItemRight{width:100%;}.memTemplParams{color:#4665A2;white-space:nowrap;}/**//**//**/.memtemplate{font-size:80%;color:#4665A2;font-weight:normal;margin-left:9px;}.memnav{background-color:#EBEFF6;border:1px solid #A3B4D7;text-align:center;margin:2px;margin-right:15px;padding:2px;}.mempage{width:100%;}.memitem{padding:0;margin-bottom:10px;margin-right:5px;}.memname{white-space:nowrap;font-weight:bold;margin-left:6px;}.memproto{border-top:1px solid #A8B8D9;border-left:1px solid #A8B8D9;border-right:1px solid #A8B8D9;padding:6px 0px 6px 0px;color:#253555;font-weight:bold;text-shadow:0px 1px 1px rgba(255,255,255,0.9);/**/  box-shadow:5px 5px 5px rgba(0,0,0,0.15);border-top-right-radius:8px;border-top-left-radius:8px;/**/-moz-box-shadow:rgba(0,0,0,0.15) 5px 5px 5px;-moz-border-radius-topright:8px;-moz-border-radius-topleft:8px;/**/-webkit-box-shadow:5px 5px 5px rgba(0,0,0,0.15);-webkit-border-top-right-radius:8px;-webkit-border-top-left-radius:8px;background-image:url('http://www.i2cdevlib.com/docs/html/nav_f.png');background-repeat:repeat-x;background-color:#E2E8F2;}.memdoc{border-bottom:1px solid #A8B8D9;border-left:1px solid #A8B8D9;border-right:1px solid #A8B8D9;padding:2px 5px;background-color:#FBFCFD;border-top-width:0;/**/border-bottom-left-radius:8px;border-bottom-right-radius:8px;box-shadow:5px 5px 5px rgba(0,0,0,0.15);/**/-moz-border-radius-bottomleft:8px;-moz-border-radius-bottomright:8px;-moz-box-shadow:rgba(0,0,0,0.15) 5px 5px 5px;background-image:-moz-linear-gradient(center top,#FFFFFF 0%,#FFFFFF 60%,#F7F8FB 95%,#EEF1F7);/**/-webkit-border-bottom-left-radius:8px;-webkit-border-bottom-right-radius:8px;-webkit-box-shadow:5px 5px 5px rgba(0,0,0,0.15);background-image:-webkit-gradient(linear,center top,center bottom,from(#FFFFFF),color-stop(0.6,#FFFFFF),color-stop(0.60,#FFFFFF),color-stop(0.95,#F7F8FB),to(#EEF1F7));}.paramkey{text-align:right;}.paramtype{white-space:nowrap;}.paramname{color:#602020;white-space:nowrap;}.paramname em{font-style:normal;}.params,.retval,.exception,.tparams{border-spacing:6px 2px;}.params .paramname,.retval .paramname{ font-weight:bold;vertical-align:top;}.params .paramtype{font-style:italic;vertical-align:top;}.params .paramdir{font-family:"courier new",courier,monospace;vertical-align:top;}/**//**//**/.ftvtree{font-family:sans-serif;margin:0px;}/**/.directory{font-size:9pt;font-weight:bold;margin:5px;}.directory h3{margin:0px;margin-top:1em;font-size:11pt;}/**//**/.directory>h3{margin-top:0;}.directory p{margin:0px;white-space:nowrap;}.directory div{display:none;margin:0px;}.directory img{vertical-align:-30%;}/**/.directory-alt{font-size:100%;font-weight:bold;}.directory-alt h3{margin:0px;margin-top:1em;font-size:11pt;}.directory-alt>h3{margin-top:0;}.directory-alt p{margin:0px;white-space:nowrap;}.directory-alt div{display:none;margin:0px;}.directory-alt img{vertical-align:-30%;}/**/div.dynheader {margin-top:8px;}address{font-style:normal;color:#2A3D61;}table.doxtable{border-collapse:collapse;}table.doxtable td,table.doxtable th{border:1px solid #2D4068;padding:3px 7px 2px;}table.doxtable th{background-color:#374F7F;color:#FFFFFF;font-size:110%;padding-bottom:4px;padding-top:5px;text-align:left;}.tabsearch{top:0px;left:10px;height:36px;background-image:url('http://www.i2cdevlib.com/docs/html/tab_b.png');z-index:101;overflow:hidden;font-size:13px;}.navpath ul{font-size:11px;background-image:url('http://www.i2cdevlib.com/docs/html/tab_b.png');background-repeat:repeat-x;height:30px;line-height:30px;color:#8AA0CC;border:solid 1px #C2CDE4;overflow:hidden;margin:0px;padding:0px;}.navpath li{list-style-type:none;float:left;padding-left:10px;padding-right:15px;background-image:url('http://www.i2cdevlib.com/docs/html/bc_s.png');background-repeat:no-repeat;background-position:right;color:#364D7C;}.navpath li.navelem a{height:32px;display:block;text-decoration:none;outline:none;}.navpath li.navelem a:hover{color:#6884BD;}.navpath li.footer{list-style-type:none;float:right;padding-left:10px;padding-right:15px;background-image:none;background-repeat:no-repeat;background-position:right;color:#364D7C;font-size:8pt;}div.summary{float:right;font-size:8pt;padding-right:5px;width:50%;text-align:right;}div.summary a{white-space:nowrap;}div.ingroups{font-size:8pt;padding-left:5px;width:50%;text-align:left;}div.ingroups a{white-space:nowrap;}div.header{background-image:url('http://www.i2cdevlib.com/docs/html/nav_h.png');background-repeat:repeat-x;background-color:#F9FAFC;margin:0px;border-bottom:1px solid #C4CFE5;}div.headertitle{padding:5px 5px 5px 10px;}dl{padding:0 0 0 10px;}dl.note,dl.warning,dl.attention,dl.pre,dl.post,dl.invariant,dl.deprecated,dl.todo,dl.test,dl.bug{border-left:4px solid;padding:0 0 0 6px;}dl.note{border-color:#D0C000;}dl.warning,dl.attention{border-color:#FF0000;}dl.pre,dl.post,dl.invariant{border-color:#00D000;}dl.deprecated{border-color:#505050;}dl.todo{border-color:#00C0E0;}dl.test{border-color:#3030E0;}dl.bug{border-color:#C08050;}#projectlogo{text-align:center;vertical-align:bottom;border-collapse:separate;}#projectlogo img{border:0px none;}#projectname{font:300% Tahoma,Arial,sans-serif;margin:0px;padding:2px 0px;}#projectbrief{font:120% Tahoma,Arial,sans-serif;margin:0px;padding:0px;}#projectnumber{font:50% Tahoma,Arial,sans-serif;margin:0px;padding:0px;}#titlearea{padding:0px;margin:0px;width:100%;border-bottom:1px solid #5373B4;}.image{text-align:center;}.dotgraph{text-align:center;}.mscgraph{text-align:center;}.caption{font-weight:bold;}
</style>
<style type="text/css" style="display:none">/**/#FSearchBox{float:left;}#searchli{float:right;display:block;width:170px;height:36px;}#MSearchBox{white-space :nowrap;position:absolute;float:none;display:inline;margin-top:8px;right:0px;width:170px;z-index:102;}#MSearchBox .left{display:block;position:absolute;left:10px;width:20px;height:19px;background:url('http://www.i2cdevlib.com/docs/html/search/search_l.png') no-repeat;background-position:right;}#MSearchSelect{display:block;position:absolute;width:20px;height:19px;}.left #MSearchSelect{left:4px;}.right #MSearchSelect{right:5px;}#MSearchField{display:block;position:absolute;height:19px;background:url('http://www.i2cdevlib.com/docs/html/search/search_m.png') repeat-x;border:none;width:116px;margin-left:20px;padding-left:4px;color:#909090;outline:none;font:9pt Arial,Verdana,sans-serif;}#FSearchBox #MSearchField{margin-left:15px;}#MSearchBox .right{display:block;position:absolute;right:10px;top:0px;width:20px;height:19px;background:url('http://www.i2cdevlib.com/docs/html/search/search_r.png') no-repeat;background-position:left;}#MSearchClose{display:none;position:absolute;top:4px;background :none;border:none;margin:0px 4px 0px 0px;padding:0px 0px;outline:none;}.left #MSearchClose{left:6px;}.right #MSearchClose{right:2px;}.MSearchBoxActive #MSearchField{color:#000000;}/**/#MSearchSelectWindow{display:none;position:absolute;left:0;top:0;border:1px solid #90A5CE;background-color:#F9FAFC;z-index:1;padding-top:4px;padding-bottom:4px;-moz-border-radius:4px;-webkit-border-top-left-radius:4px;-webkit-border-top-right-radius:4px;-webkit-border-bottom-left-radius:4px;-webkit-border-bottom-right-radius:4px;-webkit-box-shadow:5px 5px 5px rgba(0,0,0,0.15);}.SelectItem{font:8pt Arial,Verdana,sans-serif;padding-left:2px;padding-right:12px;border:0px;}span.SelectionMark{margin-right:4px;font-family:monospace;outline-style:none;text-decoration:none;}a.SelectItem{display:block;outline-style:none;color:#000000;text-decoration:none;padding-left:6px;padding-right:12px;}a.SelectItem:focus,a.SelectItem:active{color:#000000;outline-style:none;text-decoration:none;}a.SelectItem:hover{color:#FFFFFF;background-color:#3D578C;outline-style:none;text-decoration:none;cursor:pointer;display:block;}/**/iframe#MSearchResults{width:60ex;height:15em;}#MSearchResultsWindow{display:none;position:absolute;left:0;top:0;border:1px solid #000;background-color:#EEF1F7;}/**/#SRIndex{clear:both;padding-bottom:15px;}.SREntry{font-size:10pt;padding-left:1ex;}.SRPage .SREntry{font-size:8pt;padding:1px 5px;}body.SRPage{margin:5px 2px;}.SRChildren{padding-left:3ex;padding-bottom:.5em}.SRPage .SRChildren{display:none;}.SRSymbol{font-weight:bold;color:#425E97;font-family:Arial,Verdana,sans-serif;text-decoration:none;outline:none;}a.SRScope{display:block;color:#425E97;font-family:Arial,Verdana,sans-serif;text-decoration:none;outline:none;}a.SRSymbol:focus,a.SRSymbol:active,a.SRScope:focus,a.SRScope:active{text-decoration:underline;}.SRPage .SRStatus{padding:2px 5px;font-size:8pt;font-style:italic;}.SRResult{display:none;}DIV.searchresults{margin-left:10px;margin-right:10px;}
</style>
<script async="" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/a.txt" type="text/javascript"></script><script type="text/javascript" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/jquery.js"></script> <script type="text/javascript" style="display:none">var indexSectionsWithContent={0:"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100111000100001110010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",1:"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100011000100000110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",2:"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100111000100001110010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",3:"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"};var indexSectionNames={0:"all",1:"classes",2:"functions",3:"variables"};function convertToId(search)
{var result='';for(i=0;i<search.length;i++)
{var c=search.charAt(i);var cn=c.charCodeAt(0);if(c.match(/[a-z0-9]/))
{result+=c;}
else if(cn<16)
{result+="_0"+cn.toString(16);}
else
{result+="_"+cn.toString(16);}}
return result;}
function getXPos(item)
{var x=0;if(item.offsetWidth)
{while(item&&item!=document.body)
{x+=item.offsetLeft;item=item.offsetParent;}}
return x;}
function getYPos(item)
{var y=0;if(item.offsetWidth)
{while(item&&item!=document.body)
{y+=item.offsetTop;item=item.offsetParent;}}
return y;}
function SearchBox(name,resultsPath,inFrame,label)
{if(!name||!resultsPath){alert("Missing parameters to SearchBox.");}
this.name=name;this.resultsPath=resultsPath;this.keyTimeout=0;this.keyTimeoutLength=500;this.closeSelectionTimeout=300;this.lastSearchValue="";this.lastResultsPage="";this.hideTimeout=0;this.searchIndex=0;this.searchActive=false;this.insideFrame=inFrame;this.searchLabel=label;this.DOMSearchField=function()
{return document.getElementById("MSearchField");}
this.DOMSearchSelect=function()
{return document.getElementById("MSearchSelect");}
this.DOMSearchSelectWindow=function()
{return document.getElementById("MSearchSelectWindow");}
this.DOMPopupSearchResults=function()
{return document.getElementById("MSearchResults");}
this.DOMPopupSearchResultsWindow=function()
{return document.getElementById("MSearchResultsWindow");}
this.DOMSearchClose=function()
{return document.getElementById("MSearchClose");}
this.DOMSearchBox=function()
{return document.getElementById("MSearchBox");}
this.OnSearchFieldFocus=function(isActive)
{this.Activate(isActive);}
this.OnSearchSelectShow=function()
{var searchSelectWindow=this.DOMSearchSelectWindow();
var searchField=this.DOMSearchSelect();if(this.insideFrame)
{var left=getXPos(searchField);var top=getYPos(searchField);left+=searchField.offsetWidth+6;top+=searchField.offsetHeight;searchSelectWindow.style.display='block';left-=searchSelectWindow.offsetWidth;searchSelectWindow.style.left=left+'px';searchSelectWindow.style.top=top+'px';}
else
{var left=getXPos(searchField);var top=getYPos(searchField);top+=searchField.offsetHeight;searchSelectWindow.style.display='block';searchSelectWindow.style.left=left+'px';searchSelectWindow.style.top=top+'px';}
if(this.hideTimeout)
{clearTimeout(this.hideTimeout);this.hideTimeout=0;}
return false;}
this.OnSearchSelectHide=function()
{this.hideTimeout=setTimeout(this.name+".CloseSelectionWindow()",this.closeSelectionTimeout);}
this.OnSearchFieldChange=function(evt)
{if(this.keyTimeout)
{clearTimeout(this.keyTimeout);this.keyTimeout=0;}
var e=(evt)?evt:window.event;if(e.keyCode==40||e.keyCode==13)
{if(e.shiftKey==1)
{this.OnSearchSelectShow();var win=this.DOMSearchSelectWindow();for(i=0;i<win.childNodes.length;i++)
{var child=win.childNodes[i];if(child.className=='SelectItem')
{child.focus();return;}}
return;}
else if(window.frames.MSearchResults.searchResults)
{var elem=window.frames.MSearchResults.searchResults.NavNext(0);if(elem)elem.focus();}}
else if(e.keyCode==27)
{this.DOMSearchField().blur();this.DOMPopupSearchResultsWindow().style.display='none';this.DOMSearchClose().style.display='none';this.lastSearchValue='';this.Activate(false);return;}
var searchValue=this.DOMSearchField().value.replace(/ +/g,"");if(searchValue!=this.lastSearchValue)
{if(searchValue!="")
{this.keyTimeout=setTimeout(this.name+'.Search()',this.keyTimeoutLength);}
else
{this.DOMPopupSearchResultsWindow().style.display='none';this.DOMSearchClose().style.display='none';this.lastSearchValue='';}}}
this.SelectItemCount=function(id)
{var count=0;var win=this.DOMSearchSelectWindow();for(i=0;i<win.childNodes.length;i++)
{var child=win.childNodes[i];if(child.className=='SelectItem')
{count++;}}
return count;}
this.SelectItemSet=function(id)
{var i,j=0;var win=this.DOMSearchSelectWindow();for(i=0;i<win.childNodes.length;i++)
{var child=win.childNodes[i];if(child.className=='SelectItem')
{var node=child.firstChild;if(j==id)
{node.innerHTML='&bull;';}
else
{node.innerHTML='&#160;';}
j++;}}}
this.OnSelectItem=function(id)
{this.searchIndex=id;this.SelectItemSet(id);var searchValue=this.DOMSearchField().value.replace(/ +/g,"");if(searchValue!=""&&this.searchActive)
{this.Search();}}
this.OnSearchSelectKey=function(evt)
{var e=(evt)?evt:window.event;if(e.keyCode==40&&this.searchIndex<this.SelectItemCount())
{this.searchIndex++;this.OnSelectItem(this.searchIndex);}
else if(e.keyCode==38&&this.searchIndex>0)
{this.searchIndex--;this.OnSelectItem(this.searchIndex);}
else if(e.keyCode==13||e.keyCode==27)
{this.OnSelectItem(this.searchIndex);this.CloseSelectionWindow();this.DOMSearchField().focus();}
return false;}
this.CloseResultsWindow=function()
{this.DOMPopupSearchResultsWindow().style.display='none';this.DOMSearchClose().style.display='none';this.Activate(false);}
this.CloseSelectionWindow=function()
{this.DOMSearchSelectWindow().style.display='none';}
this.Search=function()
{this.keyTimeout=0;var searchValue=this.DOMSearchField().value.replace(/^ +/,"");var code=searchValue.toLowerCase().charCodeAt(0);var hexCode;if(code<16)
{hexCode="0"+code.toString(16);}
else
{hexCode=code.toString(16);}
var resultsPage;var resultsPageWithSearch;var hasResultsPage;if(indexSectionsWithContent[this.searchIndex].charAt(code)=='1')
{resultsPage=this.resultsPath+'/'+indexSectionNames[this.searchIndex]+'_'+hexCode+'.html';resultsPageWithSearch=resultsPage+'?'+escape(searchValue);hasResultsPage=true;}
else
{resultsPage=this.resultsPath+'/nomatches.html';resultsPageWithSearch=resultsPage;hasResultsPage=false;}
window.frames.MSearchResults.location.href=resultsPageWithSearch;var domPopupSearchResultsWindow=this.DOMPopupSearchResultsWindow();if(domPopupSearchResultsWindow.style.display!='block')
{var domSearchBox=this.DOMSearchBox();this.DOMSearchClose().style.display='inline';if(this.insideFrame)
{var domPopupSearchResults=this.DOMPopupSearchResults();domPopupSearchResultsWindow.style.position='relative';domPopupSearchResultsWindow.style.display='block';var width=document.body.clientWidth-8;domPopupSearchResultsWindow.style.width=width+'px';domPopupSearchResults.style.width=width+'px';}
else
{var domPopupSearchResults=this.DOMPopupSearchResults();var left=getXPos(domSearchBox)+150;var top=getYPos(domSearchBox)+20;domPopupSearchResultsWindow.style.display='block';left-=domPopupSearchResults.offsetWidth;domPopupSearchResultsWindow.style.top=top+'px';domPopupSearchResultsWindow.style.left=left+'px';}}
this.lastSearchValue=searchValue;this.lastResultsPage=resultsPage;}
this.Activate=function(isActive)
{if(isActive||this.DOMPopupSearchResultsWindow().style.display=='block')
{this.DOMSearchBox().className='MSearchBoxActive';var searchField=this.DOMSearchField(); if(searchField.value==this.searchLabel)
{searchField.value='';this.searchActive=true;}}
else if(!isActive)
{this.DOMSearchBox().className='MSearchBoxInactive';this.DOMSearchField().value=this.searchLabel;this.searchActive=false;this.lastSearchValue=''
this.lastResultsPage='';}}}
function SearchResults(name)
{this.lastMatchCount=0;this.lastKey=0;this.repeatOn=false;this.FindChildElement=function(id)
{var parentElement=document.getElementById(id);var element=parentElement.firstChild;while(element&&element!=parentElement)
{if(element.nodeName=='DIV'&&element.className=='SRChildren')
{return element;}
if(element.nodeName=='DIV'&&element.hasChildNodes())
{element=element.firstChild;}
else if(element.nextSibling)
{element=element.nextSibling;}
else
{do
{element=element.parentNode;}
while(element&&element!=parentElement&&!element.nextSibling);if(element&&element!=parentElement)
{element=element.nextSibling;}}}}
this.Toggle=function(id)
{var element=this.FindChildElement(id);if(element)
{if(element.style.display=='block')
{element.style.display='none';}
else
{element.style.display='block';}}
}
this.Search=function(search)
{if(!search)
{search=window.location.search;search=search.substring(1);search=unescape(search);}
search=search.replace(/^ +/,"");search=search.replace(/ +$/,"");search=search.toLowerCase();search=convertToId(search);var resultRows=document.getElementsByTagName("div");var matches=0;var i=0;while(i<resultRows.length)
{var row=resultRows.item(i);if(row.className=="SRResult")
{var rowMatchName=row.id.toLowerCase();rowMatchName=rowMatchName.replace(/^sr\d*_/,'');if(search.length<=rowMatchName.length&&rowMatchName.substr(0,search.length)==search)
{row.style.display='block';matches++;}
else
{row.style.display='none';}}
i++;}
document.getElementById("Searching").style.display='none';if(matches==0)
{document.getElementById("NoMatches").style.display='block';}
else
{document.getElementById("NoMatches").style.display='none';}
this.lastMatchCount=matches;return true;}
this.NavNext=function(index)
{var focusItem;while(1)
{var focusName='Item'+index;focusItem=document.getElementById(focusName);if(focusItem&&focusItem.parentNode.parentNode.style.display=='block')
{break;}
else if(!focusItem)
{break;}
focusItem=null;index++;}
return focusItem;}
this.NavPrev=function(index)
{var focusItem;while(1)
{var focusName='Item'+index;focusItem=document.getElementById(focusName);if(focusItem&&focusItem.parentNode.parentNode.style.display=='block')
{break;}
else if(!focusItem)
{break;}
focusItem=null;index--;}
return focusItem;}
this.ProcessKeys=function(e)
{if(e.type=="keydown")
{this.repeatOn=false;this.lastKey=e.keyCode;}
else if(e.type=="keypress")
{if(!this.repeatOn)
{if(this.lastKey)this.repeatOn=true;return false;}}
else if(e.type=="keyup")
{this.lastKey=0;this.repeatOn=false;}
return this.lastKey!=0;}
this.Nav=function(evt,itemIndex)
{var e=(evt)?evt:window.event;if(e.keyCode==13)return true;if(!this.ProcessKeys(e))return false;if(this.lastKey==38)
{var newIndex=itemIndex-1;var focusItem=this.NavPrev(newIndex);if(focusItem)
{var child=this.FindChildElement(focusItem.parentNode.parentNode.id);if(child&&child.style.display=='block')
{var n=0;var tmpElem;while(1)
{tmpElem=document.getElementById('Item'+newIndex+'_c'+n);if(tmpElem)
{focusItem=tmpElem;}
else
{break;}
n++;}}}
if(focusItem)
{focusItem.focus();}
else
{parent.document.getElementById("MSearchField").focus();}}
else if(this.lastKey==40)
{var newIndex=itemIndex+1;var focusItem;var item=document.getElementById('Item'+itemIndex);var elem=this.FindChildElement(item.parentNode.parentNode.id);if(elem&&elem.style.display=='block')
{focusItem=document.getElementById('Item'+itemIndex+'_c0');}
if(!focusItem)focusItem=this.NavNext(newIndex);if(focusItem)focusItem.focus();}
else if(this.lastKey==39)
{var item=document.getElementById('Item'+itemIndex);var elem=this.FindChildElement(item.parentNode.parentNode.id);if(elem)elem.style.display='block';}
else if(this.lastKey==37)
{var item=document.getElementById('Item'+itemIndex);var elem=this.FindChildElement(item.parentNode.parentNode.id);if(elem)elem.style.display='none';}
else if(this.lastKey==27)
{parent.searchBox.CloseResultsWindow();parent.document.getElementById("MSearchField").focus();}
else if(this.lastKey==13)
{return true;}
return false;}
this.NavChild=function(evt,itemIndex,childIndex)
{var e=(evt)?evt:window.event;if(e.keyCode==13)return true;if(!this.ProcessKeys(e))return false;if(this.lastKey==38)
{if(childIndex>0)
{var newIndex=childIndex-1;document.getElementById('Item'+itemIndex+'_c'+newIndex).focus();}
else
{document.getElementById('Item'+itemIndex).focus();}}
else if(this.lastKey==40)
{var newIndex=childIndex+1;var elem=document.getElementById('Item'+itemIndex+'_c'+newIndex);if(!elem)
{elem=this.NavNext(itemIndex+1);}
if(elem)
{elem.focus();}}
else if(this.lastKey==27)
{parent.searchBox.CloseResultsWindow();parent.document.getElementById("MSearchField").focus();}
else if(this.lastKey==13)
{return true;}
return false;}}
</script> <script type="text/javascript">$(document).ready(function() { searchBox.OnSelectItem(0); });
</script> <style type="text/css" style="display:none">/**//**/#pageWrapper{}#pageHeader{margin:1.5em 0;}#pageMenu{background-color:#000;border:solid #222;border-width:1px 0;box-shadow:0 0.5em 1em #888;height:42px;margin:1em 0 2em;position:relative;z-index:1;}#pageBody{min-height:400px;}#pageFooter{background-color:#EEE;border-top:1px solid #DDD;border-bottom:1px solid #CCC;box-shadow:0 0.5em 1em #888;font-size:0.9em;font-style:italic;text-align:right;margin-top:4em;}#pageFooter>div{padding:1em;}#logo{}#slogan{bottom:0;float:right;position:absolute;right:0;}div.wrap960{display:block;margin:0 auto;position:relative;width:960px;}/**/div.platforms-home{float:right;margin-left:24px;width:235px;}div.platforms-home h2{background-color:#DDD;border:1px solid;border-color:#EEE #BBB #999 #DDD;border-top:1px solid #EEE;margin:0 0 8px;padding:4px 0;text-align:center;text-shadow:0 1px 1px #FFF;}div.platforms-home table{border-collapse:collapse;margin-bottom:16px;width:100%;}div.platforms-home table td{border:0;padding:8px 0;text-align:center;}div.description-home h2{border-bottom:1px solid #CCC;clear:left;padding-top:16px;padding-bottom:4px;}div.description-home a img{border:1px solid #CCC;box-shadow:0.5em 0.5em 1em #CCC;float:left;margin:0 2em 2em 0;}table.chipin{border-collapse:collapse;margin:12px auto 24px;width:800px;}table.chipin td{border:solid #CCC;border-width:1px 0;padding:32px 0;text-align:center;width:33%;vertical-align:middle;}/**/table.devices{box-shadow:0.25em 0.25em 1em #AAA;margin-bottom:2.5em;width:100%;}table.devices thead th{background-color:#CCC;border:1px solid #AAA;font-weight:bold;padding:6px 10px;text-align:left;}table.devices tbody th{}table.devices tbody td{border:1px solid #CCC;padding:6px 10px;}table.devices tbody tr:nth-child(even){background-color:#EEE;}/**/ul.tabs{height:29px;list-style:none;margin:0;padding:0;}ul.tabs li{float:left;margin:0 0.5em 0 0;height:29px;}ul.tabs li a{background-color:#EEE;border:1px solid #CCC;border-radius:8px 8px 0 0;display:block;font-weight:bold;padding:4px 10px;position:relative;text-decoration:none;z-index:5;}ul.tabs li a.active{background-color:#FFF;border-bottom-color:#FFF;}ul.tabs li a:hover{background-color:#EEF;}ul.tabs li a span.icon{display:block;float:left;height:16px;margin-right:6px;margin-top:2px;width:16px;}ul.tabs li a span.icon.source{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/file_extension_rtf.png);}ul.tabs li a span.icon.registers{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/processor.png);}ul.tabs li a span.icon.captures{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/monitor.png);}ul.tabs li a span.icon.links{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/link.png);}ul.tabs li a span.icon.help{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/question.png);}div.tabContainer{border:solid #CCC;border-width:1px;display:none;min-height:300px;padding:1em;overflow:hidden;width:100%;}div.tabContainer.active{display:block;}ul.faq .question{background-color:#F4F4F4;border:1px solid #CCC;border-radius:3px;font-weight:bold;margin-bottom:1em;padding:0.8em 1em;}ul.faq .question:hover{background-color:#FDD;border-color:#A55;cursor:pointer;}ul.faq .answer{display:none;margin-bottom:2em;padding:2px 4px;}ul.faq li.active .answer{display:block;}ul.faq .author{color:#555;float:right;font-size:0.85em;font-style:italic;font-weight:normal;margin:3px 3px 0 16px;}/**/table.registers{border:1px solid #AAA;border-collapse:collapse;margin-bottom:16px;}table.registers th,table.registers td{font-family:Consolas,Courier New,monospace;font-size:10pt;}table.registers th{background-color:#666;background-image:-webkit-gradient(linear,center bottom,center top,from(#555),color-stop(0.5,#777));border:1px solid #333;color:#FFF;padding:4px 6px;position:relative;text-align:left;text-shadow:1px 1px #000;}table.registers thead th{text-align:center;}table.registers thead th:nth-child(1){background-color:#DDD;}table.registers tbody tr:hover th{background-color:#AA8;background-image:-webkit-gradient(linear,center bottom,center top,from(#553),color-stop(0.5,#AA8));}table.registers td{background-image:-webkit-gradient(linear,center top,center bottom,from(#EEE),color-stop(0.2,#FFF));border:1px solid #DDD;padding:4px 6px;position:relative;text-align:center;text-shadow:1px 1px #EEE;}table.registers tr.rw0 td.rw{background:rgba(0,0,255,0.1);}table.registers tr.rw1 td.rw{background:rgba(0,255,0,0.1);}table.registers tr.rw2 td.rw{background:rgba(255,0,0,0.1);}table.registers td:hover{background-color:#FF8;background-image:-webkit-gradient(linear,center top,center bottom,from(#EE6),color-stop(0.2,#FF8));pointer:default;text-shadow:1px 1px #EE6;}table.registers td.missing{background-color:#FFF;background-image:url(http://www.i2cdevlib.com/assets/css/../images/crosshatch.png);}table.registers th.corner{background:transparent!important;border-top-color:#FFF;border-left-color:#FFF;}table.registers div.tip{display:none;}table.registers span.tipvis{background-image:url(http://www.i2cdevlib.com/assets/css/../images/tipvis-red.png);display:block;height:5px;position:absolute;top:0;right:0;width:5px;}table.registers th span.tipvis{background-image:url(http://www.i2cdevlib.com/assets/css/../images/tipvis-yellow.png);}/**/table.register-definitions{border:1px solid #AAA;border-collapse:collapse;margin-bottom:16px;width:100%;}table.register-definitions>tbody>tr{border-bottom:3px solid #000;}table.register-definitions>tbody>tr.dumptemplate{display:none;}table.register-definitions>tbody>tr.regtemplate{display:none;}table.register-definitions>tbody>tr.fieldtemplate{display:none;}table.register-definitions th,table.register-definitions td{font-family:Consolas,Courier New,monospace;font-size:10pt;}table.register-definitions>tbody>tr>th{background-color:#AAA;background-image:-webkit-gradient(linear,center bottom,center top,from(#EEE),color-stop(1,#FFF));border:1px solid #333;font-size:12pt;font-weight:bold;padding:4px 6px;text-align:center;text-shadow:0 1px #FFF;vertical-align:middle;width:40px;}table.register-definitions>tbody>tr>td{padding:4px 6px;}table.register-definitions>thead>tr>th{background-color:#666;background-image:-webkit-gradient(linear,center bottom,center top,from(#555),color-stop(0.5,#777));border:1px solid #333;color:#FFF;padding:4px 6px;text-align:left;text-shadow:1px 1px #000;}table.register-definitions>thead>tr>th{text-align:center;}table.register-definitions>tbody>tr:hover>th{background-color:#AA8;background-image:-webkit-gradient(linear,center bottom,center top,from(#FFC),color-stop(1,#FFF));}table.register-definitions>tbody>tr>td{background-image:-webkit-gradient(linear,center top,center bottom,from(#EEE),color-stop(0.2,#FFF));border:1px solid #DDD;padding:4px 6px;text-align:left;text-shadow:1px 1px #EEE;}table.register-definitions>tbody>tr>td:hover{background-color:#FF8;background-image:-webkit-gradient(linear,center top,center bottom,from(#EE6),color-stop(0.2,#FF8));pointer:default;text-shadow:1px 1px #EE6;}table.register-definitions>tbody>tr>td.missing{background-color:#FFF;background-image:url(http://www.i2cdevlib.com/assets/css/../images/crosshatch.png);}table.register-definitions th.corner{background:transparent!important;border-top-color:#FFF;border-left-color:#FFF;}table.register-definitions input,table.register-definitions textarea,table.register-definitions select{background-color:#FFF;border:1px solid #CCC;display:block;}table.register-definitions textarea{/**/width:80%;}table.register-definitions>tbody>tr>td input{}table.register-definitions td.addrow input{display:inline;}table.register-definitions input:focus,table.register-definitions textarea:focus{background-image:-webkit-gradient(linear,center top,center bottom,from(#6E6),color-stop(0.2,#CFC));}table.register-definitions>tfoot>tr>td.addrow{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/32/add.png) center center no-repeat #FFF;height:32px;opacity:0.5;padding:4px 6px;vertical-align:center;}table.register-definitions>tfoot>tr>td.addrow:hover{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/32/add.png) center center no-repeat #CDF;cursor:pointer;opacity:1;}table.register-definitions>tbody>tr>td.deleterow{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/32/delete.png) center center no-repeat #FFF;opacity:0.5;width:32px;}table.register-definitions>tbody>tr>td.deleterow:hover{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/32/delete.png) center center no-repeat #FEE;cursor:pointer;opacity:1;}table.register-definitions label{background-color:rgba(0,0,0,0.05);clear:both;color:#333;display:block;float:left;font-weight:bold;margin:0 2px 2px 0;padding:1px 2px;text-shadow:none;width:130px;}/**/table.register-fields{/**/border-collapse:collapse;margin-top:16px;width:100%;}table.register-fields th,table.register-fields td{font-family:Consolas,Courier New,monospace;font-size:10pt;}table.register-fields>tbody>tr.template{display:none;}table.register-fields>tbody>tr>th{background-color:#AAA;background-image:-webkit-gradient(linear,center bottom,center top,from(#EEE),color-stop(1,#FFF));border:1px solid #CCC;font-weight:bold;padding:4px 6px;text-align:right;text-shadow:0 1px #FFF;vertical-align:middle;width:40px;}table.register-fields>thead>tr>th{background-color:#666;background-image:-webkit-gradient(linear,center bottom,center top,from(#999),color-stop(0.5,#EEE));border:1px solid #CCC;color:#000;padding:4px 6px;text-align:left;text-shadow:0px 1px #FFF;}table.register-fields thead th{text-align:center;}table.register-fields>tbody>tr:hover>th{background-color:#AA8;background-image:-webkit-gradient(linear,center bottom,center top,from(#CDF),color-stop(1,#FFF));}table.register-fields td{background-image:-webkit-gradient(linear,center top,center bottom,from(#EEE),color-stop(0.2,#FFF));border:1px solid #DDD;padding:4px 6px;text-align:left;text-shadow:1px 1px #EEE;}table.register-fields td:hover{background-color:#FF8;background-image:-webkit-gradient(linear,center top,center bottom,from(#BCF),color-stop(0.2,#EEF));pointer:default;text-shadow:1px 1px #EE6;}table.register-fields td.missing{background-color:#FFF;/**/}table.register-fields th.corner{background:transparent!important;border-top-color:#FFF;border-left-color:#FFF;}table.register-fields>tfoot>tr>td.addrow{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/add.png) center center no-repeat #FFF;height:16px;opacity:0.5;}table.register-fields>tfoot>tr>td.addrow:hover{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/add.png) center center no-repeat #CDF;cursor:pointer;opacity:1;}table.register-fields>tbody>tr>td.deleterow{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/delete.png) center center no-repeat #FFF;opacity:0.5;width:16px;}table.register-fields>tbody>tr>td.deleterow:hover{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/delete.png) center center no-repeat #FEE;cursor:pointer;opacity:1;}table.register-fields label{background-color:rgba(0,0,100,0.1);color:#038;}/**/table.register-field-options{/**/border-collapse:collapse;/**/width:81%;}table.register-field-options th,table.register-field-options td{font-family:Consolas,Courier New,monospace;font-size:10pt;}table.register-field-options>tbody>tr.template{display:none;}table.register-field-options>tbody>tr>th{background-color:#AAA;background-image:-webkit-gradient(linear,center bottom,center top,from(#EEE),color-stop(1,#FFF));border:1px solid #CCC;font-weight:bold;padding:4px 6px;text-align:right;text-shadow:0 1px #FFF;vertical-align:middle;width:40px;}table.register-field-options>thead>tr>th{background-color:#666;background-image:-webkit-gradient(linear,center bottom,center top,from(#F55),color-stop(0.5,#FCC));border:1px solid #CCC;color:#000;padding:4px 6px;text-align:left;text-shadow:0px 1px #FFF;}table.register-field-options thead th{text-align:center;}table.register-field-options>tbody>tr:hover>th{background-color:#AA8;background-image:-webkit-gradient(linear,center bottom,center top,from(#CDF),color-stop(1,#FFF));}table.register-field-options td{background-image:-webkit-gradient(linear,center top,center bottom,from(#EEE),color-stop(0.2,#FFF));border:1px solid #DDD;padding:4px 6px;text-align:left;text-shadow:1px 1px #EEE;}table.register-field-options td:hover{background-color:#FF8;background-image:-webkit-gradient(linear,center top,center bottom,from(#BCF),color-stop(0.2,#EEF));pointer:default;text-shadow:1px 1px #EE6;}table.register-field-options td.missing{background-color:#FFF;/**/}table.register-field-options th.corner{background:transparent!important;border-top-color:#FFF;border-left-color:#FFF;}table.register-field-options>tfoot>tr>td.addrow{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/add.png) center center no-repeat #FFF;height:16px;opacity:0.5;}table.register-field-options>tfoot>tr>td.addrow:hover{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/add.png) center center no-repeat #CDF;cursor:pointer;opacity:1;}table.register-field-options>tbody>tr>td.deleterow{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/delete.png) center center no-repeat #FFF;opacity:0.5;width:16px;}table.register-field-options>tbody>tr>td.deleterow:hover{background:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/delete.png) center center no-repeat #FEE;cursor:pointer;opacity:1;}table.register-field-options label{background-color:rgba(0,0,100,0.1);color:#038;}div.balloon{background-color:#F6F6F6;border:1px solid #CCC;border-radius:5px;box-shadow:4px 4px 4px #555;padding:12px;max-width:600px;max-height:400px;opacity:0.95;overflow-y:auto;z-index:32767;}div.balloon table{background-color:#FFF;border-collapse:collapse;}div.balloon table th{background-color:#EEE;font-weight:bold;}div.balloon table th,td{border:1px solid #CCC;padding:2px 4px;}span.editable{/**/cursor:pointer;display:block;min-height:18px;min-width:64px;overflow:hidden;position:relative;}span.editable span.edittip{background-color:#333;border:solid #000;border-width:0 1px 1px 1px;bottom:-1.8em;color:#FFF;display:none;font-size:10px;padding:0;/**/position:absolute;right:0;text-shadow:none;z-index:100;}span.editable:hover{/**/}span.editable:hover span.edittip{display:block;}span.editable textarea,span.editable input{font:inherit;display:none;width:98%;}span.editable.editing span.value{display:none;}span.editable.editing textarea,span.editable.editing input{display:inline-block;}span.editable.editing:hover span.edittip{display:none;}input.changed,textarea.changed,select.changed{box-shadow:0 0 0.75em #00F;}/**/table.packets{border:1px solid #AAA;border-collapse:collapse;margin-bottom:16px;}table.packets td.minwidth{min-width:953px;width:953px;}table.packets th,table.packets td{font-family:Consolas,Courier New,monospace;font-size:10pt;}table.packets th{background-color:#666;border:1px solid #AAA;color:#FFF;padding:1px 3px;position:relative;text-align:left;}table.packets th a{color:#FF0;}table.packets th a:hover{color:#FFB;}table.packets td{border:1px solid #AAA;padding:1px 3px;position:relative;}table.packets tr.read{background-color:#DFD;}table.packets tr.read:nth-child(odd){background-color:#BFB;}table.packets tr.write{background-color:#FDC;}table.packets tr.write:nth-child(odd){background-color:#FBA;}table.packets td span.detail{position:relative;}table.packets td span.detail.dev,table.packets td span.detail.reg{font-weight:bold;}table.packets td span.extended.ellipsis{background-color:rgba(0,0,0,0.1);color:#666;font-style:italic;}table.packets td span.extended.ellipsis:hover{background-color:rgba(255,255,255,0.3);cursor:default;}table.packets td span.detail{font-style:italic;}table.packets tr td:nth-child(3){background-color:rgba(255,255,255,0.5);}table.packets td span.detail.dev{background-color:rgba(0,0,0,0.1);}table.packets td span.detail.reg{background-color:rgba(192,192,255,0.3);}table.packets td span.detail.data{background-color:rgba(255,255,0,0.3);}table.packets td span.detail:hover{background-color:rgba(255,255,255,0.7);cursor:default;}table.packets div.tip{display:none;}table.packets span.tipvis{background-image:url(http://www.i2cdevlib.com/assets/css/../images/tipvis-red.png);display:block;height:5px;position:absolute;top:0;right:0;width:5px;}table.packets th span.tipvis{background-image:url(http://www.i2cdevlib.com/assets/css/../images/tipvis-yellow.png);}/**/ul.dump-info{list-style:none;margin-left:0;margin-bottom:0;padding-left:0;}ul.dump-info ul{margin-bottom:0;}ul.dump-info>li{background:url(http://www.i2cdevlib.com/assets/images/icons/16/info.png) 0 2px no-repeat;padding-left:20px;padding-bottom:4px;}ul.dump-info>li.ok{background-image:url(http://www.i2cdevlib.com/assets/images/icons/16/ok.png);}ul.dump-info>li.warning{background-image:url(http://www.i2cdevlib.com/assets/images/icons/16/warning.png);}ul.dump-info>li.error{background-image:url(http://www.i2cdevlib.com/assets/images/icons/16/error.png);}ul.dump-info>li.info{background-image:url(http://www.i2cdevlib.com/assets/images/icons/16/info.png);}ul.spaced>li,ol.spaced>li{margin-bottom:1em;}ul.spaced>li:last-child,ol.spaced>li:last-child{margin-bottom:0;}ul.emphasis,ol.emphasis{background-color: #EEE;border:1px solid #CCC;border-radius:5px;padding:1em 1em 1em 2.5em;}ul.emphasis>li,ol.emphasis>li{background-color:#FFF;border:1px solid #DDD;border-radius:3px;padding:1em;}span.domain{color:#666;font-size:0.8em;font-style:italic;}img.device-image{box-shadow:0.5em 0.5em 1em #AAA;-moz-box-shadow:0.5em 0.5em 1em #AAA;-webkit-box-shadow:0.5em 0.5em 1em #AAA;float:right;margin-left:32px;}code.inline{background-color:#F6F6F6;display:inline-block;font-family:Consolas,"Courier New",monospace;padding:0 3px;}div.syntaxhighlighter{border:1px solid #CCC;border-radius:3px;}ul.plain{list-style:none;}ul.plain span.icon{margin-top:2px;}span.icon{display:block;width:16px;height:16px;float:left;margin-right:4px;}span.icon.right{float:right;margin-right:0;margin-left:4px;}span.icon.product{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/processor.png);}span.icon.purchase{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/money_dollar.png);}span.icon.documentation{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/file_extension_rtf.png);}span.icon.code{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/file_extension_log.png);}span.icon.datasheet{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/file_extension_rtf.png);}span.icon.dump{background-image:url(http://www.i2cdevlib.com/assets/css/../images/icons/16/document_layout.png);}/**/a.button,div.button,button{background:#FFF url(http://www.i2cdevlib.com/assets/css/../images/btn-gradient.png) 50% repeat-x;border:1px solid;border-color:#BBB #888 #888 #BBB;color:#000;display:block;font-weight:bold;overflow:hidden;padding:3px 8px;text-align:center;text-decoration:none;border-radius:10px;-khtml-border-radius:10px;-moz-border-radius:10px;-webkit-border-radius:10px;}a.button:hover,button:hover{background-color:#EEE;border-color:#AAA #666 #666 #AAA;}a.button:active,button:active{background:#AAA;border-color:#555 #AAA #AAA #555;}a.button.big,button.big{font-size:1.4em;line-height:1em;padding:5px 10px;}a.button.small,button.small{font-size:0.9em;line-height:1em;padding:2px 5px;}a.button.blue{background-color:#1375BC;border-color:#36F #36A #36A #36F;color:#FFF;}a.button.blue:hover{background-color:#2385EC;border-color:#47F #56A #56A #47F;}a.button.blue:active{background-color:#1365AC;border-color:#36F #36A #36A #36F;}a.button.green{background-color:#39B54A;border-color:#ADA #2A2 #2A2 #ADA;color:#FFF;}a.button.green:hover{background-color:#59D55A;border-color:#CFC #4B4 #4B4 #CFC;}a.button.green:active{background-color:#19A51A;border-color:#ADA #2A2 #2A2 #ADA;}a.button.orange{background-color:#F57F29;border-color:#DCA #872 #872 #DCA;color:#FFF;}a.button.orange:hover{background-color:#F59F59;border-color:#FEB #CB4 #CB4 #FEB;}a.button.orange:active{background-color:#D55F09;border-color:#DCA #872 #872 #DCA;}a.button.red{background-color:#F52929;border-color:#DAA #822 #822 #DAA;color:#FFF;}a.button.red:hover{background-color:#F55959;border-color:#FBB #C44 #C44 #FBB;}a.button.red:active{background-color:#D50909;border-color:#DAA #822 #822 #DAA;}
</style>
<style type="text/css" style="display:none">/**/.font12e{font-size:1.2em;line-height:1.2em;}.font13e{font-size:1.3em;line-height:1.2em;}.font14e{font-size:1.4em;line-height:1.2em;}.font15e{font-size:1.5em;line-height:1.2em;}.font20e{font-size:2.0em;line-height:1.2em;}.bold{font-weight:bold;}.italic{font-style:italic;}.underline{text-decoration:underline;}/**/.autoCenter{margin-left:auto;margin-right:auto;}.alignLeft{text-align:left;}.alignCenter{text-align:center;}.alightRight{text-align:right;}.valignTop{vertical-align:top;}.valignMiddle{vertical-align:middle;}.valignBottom{vertical-align:bottom;}.floatLeft{float:left;}.floatRight{float:right;}.imageLeft{float:left;margin-right:24px;margin-bottom:16px;}.imageRight{float:right;margin-left:24px;margin-bottom:16px;}.absolute{position:absolute;}.relative{position:relative;}.fixed{position:fixed;}.static{position:static;}.inline{display:inline;}.block{display:block;}.hidden{display:none;}.invisible{visibility:hidden;}.overhide{overflow:hidden;}.overclear{overflow:hidden;clear:both;}.clear{clear:both;}.clearLeft{clear:left;}.clearRight{clear:right;}/**/.width100a{width:100px;}.width200a{width:200px;}.width300a{width:300px;}.width400a{width:400px;}.width500a{width:500px;}.width600a{width:600px;}.width700a{width:700px;}.width800a{width:800px;}.width900a{width:900px;}.width1000a{width:1000px;}/**/.width10p{width:10%;}.width20p{width:20%;}.width25p{width:25%;}.width30p{width:30%;}.width33p{width:33%;}.width40p{width:40%;}.width50p{width:50%;}.width60p{width:60%;}.width70p{width:70%;}.width75p{width:75%;}.width80p{width:80%;}.width90p{width:90%;}.width100p{width:100%;}/**/.margin8{margin:8px;}.margin16{margin:16px;}.margin32{margin:32px;}.margin64{margin:64px;}.marginTop8{margin-top:8px;}.marginTop16{margin-top:16px;}.marginTop32{margin-top:32px;}.marginTop64{margin-top:64px;}.marginBottom8{margin-bottom:8px;}.marginBottom16{margin-bottom:16px;}.marginBottom32{margin-bottom:32px;}.marginBottom64{margin-bottom:64px;}.marginLeft8{margin-left:8px;}.marginLeft12{margin-left:12px;}.marginLeft16{margin-left:16px;}.marginLeft32{margin-left:32px;}.marginLeft64{margin-left:64px;}.marginRight8{margin-right:8px;}.marginRight12{margin-right:12px;}.marginRight16{margin-right:16px;}.marginRight32{margin-right:32px;}.marginRight64{margin-right:64px;}.marginHorizontal8{margin-left:8px;margin-right:8px;}.marginHorizontal16{margin-left:16px;margin-right:16px;}.marginHorizontal32{margin-left:32px;margin-right:32px;}.marginHorizontal64{margin-left:64px;margin-right:64px;}.marginVertical8{margin-top:8px;margin-bottom:8px;}.marginVertical16{margin-top:16px;margin-bottom:16px;}.marginVertical32{margin-top:32px;margin-bottom:32px;}.marginVertical64{margin-top:64px;margin-bottom:64px;}/**/.padding8{padding:8px;}.padding12{padding:12px;}.padding16{padding:16px;}.padding32{padding:32px;}.padding64{padding:64px;}.paddingHorizontal8{padding-left:8px;padding-right:8px;}.paddingHorizontal16{padding-left:16px;padding-right:16px;}.paddingHorizontal32{padding-left:32px;padding-right:32px;}.paddingHorizontal64{padding-left:64px;padding-right:64px;}.paddingVertical8{padding-top:8px;padding-bottom:8px;}.paddingVertical16{padding-top:16px;padding-bottom:16px;}.paddingVertical32{padding-top:32px;padding-bottom:32px;}.paddingVertical64{padding-top:64px;padding-bottom:64px;}
</style>
</head><body><div id="pageWrapper"><div id="pageHeader"><div class="wrap960"><a href="http://www.i2cdevlib.com/"><img id="logo" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/logo-full-200.png" height="77" width="200"></a> <img id="slogan" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/slogan-600.png" height="39" width="600"></div></div></div><div id="top"><!--//--><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px; display: none;"><td style="padding-left: 0.5em;"><div id="projectname">I2Cdevlib</div><div id="projectbrief"><p>I2C device library collection for AVR/Arduino or other C++-based MCUs</p></div></td></tr></tbody></table></div><script type="text/javascript"><!--
var searchBox=new SearchBox("searchBox","search",false,'Search');
--></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="http://www.i2cdevlib.com/docs/html/index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="http://www.i2cdevlib.com/docs/html/annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="http://www.i2cdevlib.com/docs/html/files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/close.png" alt="" border="0"></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="http://www.i2cdevlib.com/docs/html/annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="http://www.i2cdevlib.com/docs/html/classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="http://www.i2cdevlib.com/docs/html/functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">MPU6050 Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MPU6050" --><table class="memberdecls">
<tbody><tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7c0146d45537e4bd7a0d4c1c476fdab7">MPU6050</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a94df4ec1565317ba5279122b3bf7e056">MPU6050</a> (uint8_t address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#abd8fc6c18adf158011118fbccc7e7054">initialize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a95ffab7b44fce3834236e0813687d11a">testConnection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af6e9af8e2222889fd5458e2ae12c55c8">getAuxVDDIOLevel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7c666c20e26869bc80646f1b2c3d69bc">setAuxVDDIOLevel</a> (uint8_t level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a887a173e079980505763ffd1aa9fec05">getRate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7d03801d6b656e8e12cd3c1dd97824a8">setRate</a> (uint8_t rate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a902a7d486cd6ac21f8c378634dc6f59a">getExternalFrameSync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a77b36f41c531a11b5a835fc75a9aefe6">setExternalFrameSync</a> (uint8_t sync)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9f2737fe22955fd85b2575ba8da874c6">getDLPFMode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7a782ade8af2f88dfef7171487f59a3b">setDLPFMode</a> (uint8_t bandwidth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#acb1fa088d43d76230106a3226f343013">getFullScaleGyroRange</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a72afc0b6f221c9336f635b5637c62dae">setFullScaleGyroRange</a> (uint8_t range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8fc7eab1302281f6e4bc953379f3237b">getAccelXSelfTest</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac2ab843dc9d241056ed0f891195cdbf9">setAccelXSelfTest</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a2523e798db3baf9cb9dbf347af16639b">getAccelYSelfTest</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ad5847430ab297959e4d0e9b81ba2e3ba">setAccelYSelfTest</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a57710638eeb6176cf14a8c444bda5300">getAccelZSelfTest</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8eb8ba039af9a47e0475a3835b87f404">setAccelZSelfTest</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0fe2dad60c170cee7d614e08f243ffd0">getFullScaleAccelRange</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a64eb78e8e359c541beaf8664db3421d1">setFullScaleAccelRange</a> (uint8_t range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4c3b84a906fcb5a65870fa557f797f4a">getDHPFMode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a44cc43aaad1e52c1ba3142d4490af611">setDHPFMode</a> (uint8_t mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac7f5c0511fe9d0f3525a3757498daed7">getFreefallDetectionThreshold</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af704e1a4eb01522b146abeba78c32716">setFreefallDetectionThreshold</a> (uint8_t threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3cff6b9613ad01aa1a51c287f5c5e329">getFreefallDetectionDuration</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a41eeb40a654465966d260e3d31c4de4b">setFreefallDetectionDuration</a> (uint8_t duration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ab7a825b1b8b86cebda308289630795e7">getMotionDetectionThreshold</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aa23c8d66502345c30915e69975fd2cc9">setMotionDetectionThreshold</a> (uint8_t threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ba035c2ae4a05d7e51b0d29e4924fb0">getMotionDetectionDuration</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6d81616aaa47539217057891c91ff08f">setMotionDetectionDuration</a> (uint8_t duration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ad941c1e844dc9230675c115734599ea3">getZeroMotionDetectionThreshold</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a347a51fd25de20b9ead4659015ef793b">setZeroMotionDetectionThreshold</a> (uint8_t threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a04c0fcdcd0157b6dbf74d4901424801e">getZeroMotionDetectionDuration</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6d25a21e1673682f096399b719c66d2c">setZeroMotionDetectionDuration</a> (uint8_t duration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a913c2095001e204b5b09f8382a86d2ca">getTempFIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae528a25b4997ad0e3091a012e4e4419e">setTempFIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ada9a553176b57815f23fb7d71bb85c9d">getXGyroFIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a53a03d1f255a62f01375c870cdc85767">setXGyroFIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a86c85d5b5c93df82394435b868e17463">getYGyroFIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a16eb12bbf07bc17a9d852941d834175e">setYGyroFIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#adbbbd131c74f37dd545403633eb317ff">getZGyroFIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af5b5bc39b66466ba910f6eef1259444c">setZGyroFIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ace244415128ad7a38293ad6808b7face">getAccelFIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#afccbee85f5cdc95098f6d62d8d417c3f">setAccelFIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3c2e29508607a655221a2fa4f4219b4d">getSlave2FIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a38a10ac4f30b96718ec021dc0db8587b">setSlave2FIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#afd6a9b55a589c83c9a0fb0b5b2a88234">getSlave1FIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a5d432fa2fb8b2227f50aa5c7b5befb66">setSlave1FIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6aa7aa2e3fac06f8b5ab9ee127255a5e">getSlave0FIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a97fbf27e1b827f9dfc3c28ff376b54c4">setSlave0FIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aa88483068837bd9bc9c9f6c59a7a79b7">getMultiMasterEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a039f5724974c5bf3f373ed9be031441c">setMultiMasterEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4e2ebda47b85b4c5463f041c790bf5c0">getWaitForExternalSensorEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a20dc4bdedbe1550580c28a6d090291be">setWaitForExternalSensorEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9d75ec63e2320ecfb84a2b082397f900">getSlave3FIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6ed713870c7f6d085ded91a45515a36c">setSlave3FIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6b3c3aab80fcaa384303f9df2a59d7eb">getSlaveReadWriteTransitionEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3413efbf2f4e8a27aa8768d9bc34d663">setSlaveReadWriteTransitionEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4cda448ef5c5736bd14188947342d636">getMasterClockSpeed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8a4779ea709ff0633f9798369478400b">setMasterClockSpeed</a> (uint8_t speed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af75b9f7ccac48515c7544238db0e6863">getSlaveAddress</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3c07eb2c59fff3ddc7186319ee40ba6f">setSlaveAddress</a> (uint8_t num, uint8_t address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae7e9ead9645bcef326eb579c6ab5d5ff">getSlaveRegister</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a62851e982059a2462d52c210ad764a1c">setSlaveRegister</a> (uint8_t num, uint8_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a5f14bde83fe00b27dec6776fc44e89c2">getSlaveEnabled</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#afaffa021d7bb41f3a288827080602eee">setSlaveEnabled</a> (uint8_t num, bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a18e8f3d053a68f0e5ecf497c87ecac8a">getSlaveWordByteSwap</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#abeb1f83652066d7543fd3283af794364">setSlaveWordByteSwap</a> (uint8_t num, bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#adb99955fa66300b1f0bedfcdd8187412">getSlaveWriteMode</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3d9bfcb5394c7a382009cd2dc91ce801">setSlaveWriteMode</a> (uint8_t num, bool mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a32ce8023bb80afc5d55811de70c7214f">getSlaveWordGroupOffset</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a32602ab86f70b70d3313628fc6c010ae">setSlaveWordGroupOffset</a> (uint8_t num, bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a54c2a48b3cb79106bcaf75accf6cd311">getSlaveDataLength</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ab4151353f433c533246d938fc3b78458">setSlaveDataLength</a> (uint8_t num, uint8_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4278dec5fec25be9a6f45b51a3373ad2">getSlave4Address</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6985da2cbc37be3fefbe3c16bf8d34a6">setSlave4Address</a> (uint8_t address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7bd548cb60ecceb27c72f026ec0a60f8">getSlave4Register</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae54dc358da048e61a1ac68012300fdaa">setSlave4Register</a> (uint8_t reg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a17147a6f477be79f58889e9e6329392f">setSlave4OutputByte</a> (uint8_t data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4b9e13d6776ba99e042773873557bedd">getSlave4Enabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a04be2a8c3af6ef174f97769b9b5164a9">setSlave4Enabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a051549bcfa2eeb848c8557fc3efe74da">getSlave4InterruptEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7d7498ebc26f8a1fe8c9dcf40cd5d265">setSlave4InterruptEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8d5a5e73907c78960154b92656127372">getSlave4WriteMode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af1402fe7f3e1cc0dedb6714351cbca4e">setSlave4WriteMode</a> (bool mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9a4585b3c9e61478db198011107a56a9">getSlave4MasterDelay</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac154934a43c599cdc564fb29c22c45eb">setSlave4MasterDelay</a> (uint8_t delay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9bc93f34bc3d85cbe6010b4a3a88c5a7">getSlate4InputByte</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af2820067b73f177d985ed81e894281b0">getPassthroughStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a105aefe645e7021f9ba4397e9df4114c">getSlave4IsDone</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#acd775c72f85dabfc6f8fba43da096c6d">getLostArbitration</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae9882b425cbdced4de325b608d896e10">getSlave4Nack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a55f24d2f2b13d6e28a7c8b6bf2913520">getSlave3Nack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af4b5101dab501d6df2e0cae909120771">getSlave2Nack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a65cc9d75ff347b146414685fb83fa451">getSlave1Nack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a74511edfcada3fb21c3327a0c846c72a">getSlave0Nack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a58da1dfb39eb34e3a09a9b0bf4d87f29">getInterruptMode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a003a098a1521c5ef4df50c0a8a2d47ab">setInterruptMode</a> (bool mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af66e6c7b1885dcf452e73371790fddfd">getInterruptDrive</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9d9d6aeea346e6f6fad8e4a428cf3301">setInterruptDrive</a> (bool drive)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a5502c4c2a9bc4ea9267e128b7743923d">getInterruptLatch</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#abf9ccf9eb6c7156e6660abb76734920a">setInterruptLatch</a> (bool latch)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9a098a607e20c64b60e155da35b8264f">getInterruptLatchClear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a2fa64c7030242aac18bd6727e8ca4a54">setInterruptLatchClear</a> (bool clear)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a60fc85d4f27f99d07ffb9543d5e5f347">getFSyncInterruptLevel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a2b1c75cfc29e8ff8205f4ff33a426716">setFSyncInterruptLevel</a> (bool level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4c01f9ab83b64dbbc6b62e658c3d3d9b">getFSyncInterruptEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a96aa409e02cdb7d3671890c70b44f167">setFSyncInterruptEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aed33db318a770d0020eb8b84058650f3">getI2CBypassEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aa828160756a50f414aa3f5f5f0353c70">setI2CBypassEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ada96c33957bf20c04ca598a3537358ef">getClockOutputEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a71ec4642b6f6c937bbf6a24fea4179e5">setClockOutputEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a500bb2df2e46eaecd3fb2ba7304a5ed3">getIntFreefallEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a01a24a05f06463d5277e1670d6260e03">setIntFreefallEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7de31a8e9f22765329d9f9e02db2f1f0">getIntMotionEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a2d2d1d3b03198a09c83a48ec3bc20bd8">setIntMotionEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ab3cc9bcaca6cec61e7f3f0c6c8a37db5">getIntZeroMotionEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a5e36e3acace6e545718d7997169cff9b">setIntZeroMotionEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a55f99c88cc84901f245924ed5e3fe47e">getIntFIFOBufferOverflowEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a83710a6b1e07f3b385239cc06f275cdb">setIntFIFOBufferOverflowEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a282ae29e029d88604a59c92bdf9ce252">getIntI2CMasterEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af238656844a3727fa96a8d434b55473e">setIntI2CMasterEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae15f6043a74c9c9bf9754824802ce8d3">getIntDataReadyEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a67a11be7fc7ab6b1186469b94ea33dda">setIntDataReadyEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a06bbc2116235b7cc5e28c877e0576749">getIntFreefallStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac0c0836aa0d237cac92d11591efd0d9f">getIntMotionStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#afa73a5ffdc423736ae88702a469ba3a0">getIntZeroMotionStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aa31427588f059c69d93ddb00ba257b12">getIntFIFOBufferOverflowStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a31d6c2b03fc2d6ce82d67d142f316851">getIntI2CMasterStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae4f434eb51a15b536e2e8f89a776872b">getIntDataReadyStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aabfd2920e748016383e8124a4b32ad31">getMotion9</a> (int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz, int16_t *mx, int16_t *my, int16_t *mz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6</a> (int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a658dfc7e35b7fdba360a75f137bde33a">getAcceleration</a> (int16_t *x, int16_t *y, int16_t *z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aa68475158c22128e5459c4c5e19439dc">getAccelerationX</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a27240b90d3e03c85b7a619b794bb1756">getAccelerationY</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#acf5f5a20c10d99a1bdedf139f897bfdf">getAccelerationZ</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aedfa4f1e6507f48c0a09545345a87875">getTemperature</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ca85b87e7e0230921062fce7889b0d1">getRotation</a> (int16_t *x, int16_t *y, int16_t *z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a268f52843a24992ff06a3f12392de584">getRotationX</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a97cbe7f10dd27e07bd78d1c25e4286b5">getRotationY</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae0fee1ba996a2b6f914df6fc34e7da48">getRotationZ</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7f786ab4264f40e5a95e8937ec9adcc2">getExternalSensorByte</a> (int position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aaee15e48af7ba78660b5754f3bb5f37a">getExternalSensorWord</a> (int position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#afd8983f0911e37015434bebc85185fb2">getExternalSensorDWord</a> (int position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a446d235905783c5b90637a6b6792ac76">getXNegMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a410af58f5ff5f74e4ef8d61495908226">getXPosMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6c45be7b4aa9081c83ee0f4081bf0827">getYNegMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ad959ec84b9fe9f7e416b7af252f37abc">getYPosMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3601b732eb15644212b8f29cf396e142">getZNegMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a33c766cd415fc5780417b1ed76717875">getZPosMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a384765351b5c4bd2b6efec9ed71ad1b7">getZeroMotionDetected</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a34a1def575f6abcd464afe954de8a461">setSlaveOutputByte</a> (uint8_t num, uint8_t data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0e5cb13838298609b5260fd1558f8c92">getExternalShadowDelayEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9160193d883871037c6535a9d3e02ee2">setExternalShadowDelayEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae84fd795630f9ab5e8d6b19a616a11ce">getSlaveDelayEnabled</a> (uint8_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a471929d7cf9049357c345633d22412a9">setSlaveDelayEnabled</a> (uint8_t num, bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af1599c0d70f07fd3e28683d571842c22">resetGyroscopePath</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a99ee74708c12f32e48ef5ec69ac9f4a9">resetAccelerometerPath</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a559c2d091d36a4e0489bc639916ddbb6">resetTemperaturePath</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aae903df2accc687423f9cd0a78f9cd32">getAccelerometerPowerOnDelay</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a2bbde7653d2d2d37e16e515599f3b08b">setAccelerometerPowerOnDelay</a> (uint8_t delay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af6d6fa9869636989a8b29c4827ad7de8">getFreefallDetectionCounterDecrement</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a18dd79b7c53600e9ce97eed4bfe6cf15">setFreefallDetectionCounterDecrement</a> (uint8_t decrement)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0ed8de8eb440dbfdec829297527b0da6">getMotionDetectionCounterDecrement</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a74cc3ea727afa5d4406175085e60d08c">setMotionDetectionCounterDecrement</a> (uint8_t decrement)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae2687a09ebe0d7fbbf74f560e0dd9a44">getFIFOEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a78e58ab27986db6999af775ed4d43091">setFIFOEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6b45e538f2082eb1b1975ed56e3e21bc">getI2CMasterModeEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6503f0fdfefa0fd287a75032667b7b69">setI2CMasterModeEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a269710b7bca814bbf67e7bb38c381650">switchSPIEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aafa0dc38b7ea2acd1aecd5d9df8cbd08">resetFIFO</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a96332c394f1b7efd44c83a4ff690e732">resetI2CMaster</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9a271104d3302abc4af005c69a930094">resetSensors</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7100b6d276c3c8664cf00d768b7b0dee">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a196404ef04b959083d4bf5e6f1cd8b98">getSleepEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a15ec5f8e7daf235f507c1d8b96af051a">setSleepEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a89afc5235b9088c696e2cc7841f5259a">getWakeCycleEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a340eade71cf6286f6904c2021330944e">setWakeCycleEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a31f588beab6760258212c65725eba336">getTempSensorEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0113871802e88c80fe69ce1f607987ff">setTempSensorEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ed670258a805807b5102cdc5d0996a8">getClockSource</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4c1cd147d038e024bdeaa053c4d77734">setClockSource</a> (uint8_t source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a249a905ae4572a462414f2d94236258a">getWakeFrequency</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a62495e89f4787e6b18f0f795cef2b7cd">setWakeFrequency</a> (uint8_t frequency)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a99261a04739fdb7a9a1c5b67ce3e710e">getStandbyXAccelEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af4df87fd2e87f41d06706cfd5bbc2a2c">setStandbyXAccelEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a104f2ec438d745f8fdeec202bae09b48">getStandbyYAccelEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7ce7d3299479eb66518acf0697132835">setStandbyYAccelEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#adae85612e047c4c7f0c3b7110fc92956">getStandbyZAccelEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac5fd917549d2ed0f12b8a17167271199">setStandbyZAccelEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#acb5fde4167aa54fbbe84706d577a48a6">getStandbyXGyroEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac1c6d8f623a9ca00a4ddc50f6615b977">setStandbyXGyroEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aaad2985f8d22aec123f1e1dabcdd427a">getStandbyYGyroEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ab0973d64b7132188539b07991f7ea1f0">setStandbyYGyroEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a20f7804db1a980a3c425ae44c33d420b">getStandbyZGyroEnabled</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ada7c8a873fe157703dcdc08e25b48e32">setStandbyZGyroEnabled</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ad96c7a75a39327ebaae01386bcbc58dd">getFIFOCount</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7733011d30d5b64564f6b5422d8639ae">getFIFOByte</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a66da5bc38aa82404117d1ef5306c951a">setFIFOByte</a> (uint8_t data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a35ae3c8894b3258e642043886801e031">getDeviceID</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aaefb4b3d93cf4b78d56cd63b10ea0e97">setDeviceID</a> (uint8_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d71a79f90f97f8ea0f88825502789b8"></a><!-- doxytag: member="MPU6050::getXGyroOffset" ref="a4d71a79f90f97f8ea0f88825502789b8" args="()" -->
int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getXGyroOffset</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c66eb7f77ab0ef19fca7124c63ba9d"></a><!-- doxytag: member="MPU6050::setXGyroOffset" ref="ad0c66eb7f77ab0ef19fca7124c63ba9d" args="(int8_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setXGyroOffset</b> (int8_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a829d38a14ad1096ea73ee628cdf03b53"></a><!-- doxytag: member="MPU6050::getYGyroOffset" ref="a829d38a14ad1096ea73ee628cdf03b53" args="()" -->
int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getYGyroOffset</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f547a52a20bc1ebb23faa1e6668bff1"></a><!-- doxytag: member="MPU6050::setYGyroOffset" ref="a7f547a52a20bc1ebb23faa1e6668bff1" args="(int8_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setYGyroOffset</b> (int8_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b2adfa117b435ec24b574d9821d01e"></a><!-- doxytag: member="MPU6050::getZGyroOffset" ref="a62b2adfa117b435ec24b574d9821d01e" args="()" -->
int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getZGyroOffset</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20dbe1fac22c021fb3228522aea5c96e"></a><!-- doxytag: member="MPU6050::setZGyroOffset" ref="a20dbe1fac22c021fb3228522aea5c96e" args="(int8_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setZGyroOffset</b> (int8_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9332a5050be54fa47f321be01d524b"></a><!-- doxytag: member="MPU6050::getXFineGain" ref="a9c9332a5050be54fa47f321be01d524b" args="()" -->
int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getXFineGain</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73d4473d134cf5f7c516ff38faa2b4a8"></a><!-- doxytag: member="MPU6050::setXFineGain" ref="a73d4473d134cf5f7c516ff38faa2b4a8" args="(int8_t gain)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setXFineGain</b> (int8_t gain)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad471fd5499dd2fbf730c066a8893420d"></a><!-- doxytag: member="MPU6050::getYFineGain" ref="ad471fd5499dd2fbf730c066a8893420d" args="()" -->
int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getYFineGain</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f97e86dcfa1d491d8f809112c6fb40b"></a><!-- doxytag: member="MPU6050::setYFineGain" ref="a7f97e86dcfa1d491d8f809112c6fb40b" args="(int8_t gain)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setYFineGain</b> (int8_t gain)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c980e62e6e7774299fea1c827b6e7a"></a><!-- doxytag: member="MPU6050::getZFineGain" ref="a13c980e62e6e7774299fea1c827b6e7a" args="()" -->
int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getZFineGain</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98107dec68994cfc8c8cb1d0d78d2b6b"></a><!-- doxytag: member="MPU6050::setZFineGain" ref="a98107dec68994cfc8c8cb1d0d78d2b6b" args="(int8_t gain)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setZFineGain</b> (int8_t gain)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdfe715ced419d117c2c47007d631f9e"></a><!-- doxytag: member="MPU6050::getXAccelOffset" ref="afdfe715ced419d117c2c47007d631f9e" args="()" -->
int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getXAccelOffset</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a447144e025f55b1dc96d7c209c5defd6"></a><!-- doxytag: member="MPU6050::setXAccelOffset" ref="a447144e025f55b1dc96d7c209c5defd6" args="(int16_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setXAccelOffset</b> (int16_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7753d3c3f5d9e341f1ed0712079a0d12"></a><!-- doxytag: member="MPU6050::getYAccelOffset" ref="a7753d3c3f5d9e341f1ed0712079a0d12" args="()" -->
int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getYAccelOffset</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6214fa36c8881f3b02a3e7033678bfb3"></a><!-- doxytag: member="MPU6050::setYAccelOffset" ref="a6214fa36c8881f3b02a3e7033678bfb3" args="(int16_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setYAccelOffset</b> (int16_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a45355c735a09501b6a58c92fb752c"></a><!-- doxytag: member="MPU6050::getZAccelOffset" ref="ac9a45355c735a09501b6a58c92fb752c" args="()" -->
int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getZAccelOffset</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1868b660d695eae912ef73407e21e8"></a><!-- doxytag: member="MPU6050::setZAccelOffset" ref="a4d1868b660d695eae912ef73407e21e8" args="(int16_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setZAccelOffset</b> (int16_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a609a2c49b1ab075939e2e3d16694a7c1"></a><!-- doxytag: member="MPU6050::getXGyroOffsetUser" ref="a609a2c49b1ab075939e2e3d16694a7c1" args="()" -->
int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getXGyroOffsetUser</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2306a15d278eab385af6ea0fd54c908a"></a><!-- doxytag: member="MPU6050::setXGyroOffsetUser" ref="a2306a15d278eab385af6ea0fd54c908a" args="(int16_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setXGyroOffsetUser</b> (int16_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3ae5fd84d0a125f65dd1e9f81acc636"></a><!-- doxytag: member="MPU6050::getYGyroOffsetUser" ref="ad3ae5fd84d0a125f65dd1e9f81acc636" args="()" -->
int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getYGyroOffsetUser</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8504811dc64bb338037ac7c098c86913"></a><!-- doxytag: member="MPU6050::setYGyroOffsetUser" ref="a8504811dc64bb338037ac7c098c86913" args="(int16_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setYGyroOffsetUser</b> (int16_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66da03cd0df03c49ad942643482ece9e"></a><!-- doxytag: member="MPU6050::getZGyroOffsetUser" ref="a66da03cd0df03c49ad942643482ece9e" args="()" -->
int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getZGyroOffsetUser</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada31a0757966357c75189f1cd13f0fee"></a><!-- doxytag: member="MPU6050::setZGyroOffsetUser" ref="ada31a0757966357c75189f1cd13f0fee" args="(int16_t offset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setZGyroOffsetUser</b> (int16_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d02c38682aa566b6204df3f81fbcb68"></a><!-- doxytag: member="MPU6050::getIntPLLReadyEnabled" ref="a4d02c38682aa566b6204df3f81fbcb68" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getIntPLLReadyEnabled</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef44106927c1b986588f36bffaebea54"></a><!-- doxytag: member="MPU6050::setIntPLLReadyEnabled" ref="aef44106927c1b986588f36bffaebea54" args="(bool enabled)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setIntPLLReadyEnabled</b> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3af3f3c0a16b5b68cf6301cb0ac3f392"></a><!-- doxytag: member="MPU6050::getIntDMPEnabled" ref="a3af3f3c0a16b5b68cf6301cb0ac3f392" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getIntDMPEnabled</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a889d29900cb0dd16e0199c13822f0f88"></a><!-- doxytag: member="MPU6050::setIntDMPEnabled" ref="a889d29900cb0dd16e0199c13822f0f88" args="(bool enabled)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setIntDMPEnabled</b> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a86756b7fe164e454f4801c30cdbffe"></a><!-- doxytag: member="MPU6050::getDMPInt5Status" ref="a3a86756b7fe164e454f4801c30cdbffe" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPInt5Status</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d406fd5027e7a6b0e33f5bfafc67627"></a><!-- doxytag: member="MPU6050::getDMPInt4Status" ref="a9d406fd5027e7a6b0e33f5bfafc67627" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPInt4Status</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ac1a70c4d207c93359b43e743d34839"></a><!-- doxytag: member="MPU6050::getDMPInt3Status" ref="a1ac1a70c4d207c93359b43e743d34839" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPInt3Status</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf41d1789aa02814af0319f71c57a9f"></a><!-- doxytag: member="MPU6050::getDMPInt2Status" ref="acaf41d1789aa02814af0319f71c57a9f" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPInt2Status</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82a5a98ad80c69209ef0f423287b2f76"></a><!-- doxytag: member="MPU6050::getDMPInt1Status" ref="a82a5a98ad80c69209ef0f423287b2f76" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPInt1Status</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b597f3f6b4188cbdb3feb2cd8dd3469"></a><!-- doxytag: member="MPU6050::getDMPInt0Status" ref="a2b597f3f6b4188cbdb3feb2cd8dd3469" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPInt0Status</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a559de8cd420d329c93f215938e8483e2"></a><!-- doxytag: member="MPU6050::getIntPLLReadyStatus" ref="a559de8cd420d329c93f215938e8483e2" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getIntPLLReadyStatus</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a715e66c52a2272b54782058772b50d61"></a><!-- doxytag: member="MPU6050::getIntDMPStatus" ref="a715e66c52a2272b54782058772b50d61" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getIntDMPStatus</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a17e3062b1f321d260fd70f308c6a06"></a><!-- doxytag: member="MPU6050::getDMPEnabled" ref="a2a17e3062b1f321d260fd70f308c6a06" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPEnabled</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb6bf6db86b84700c7f13bd838d63755"></a><!-- doxytag: member="MPU6050::setDMPEnabled" ref="abb6bf6db86b84700c7f13bd838d63755" args="(bool enabled)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setDMPEnabled</b> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a9706f177e84b295739198e6b2ded95"></a><!-- doxytag: member="MPU6050::resetDMP" ref="a7a9706f177e84b295739198e6b2ded95" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>resetDMP</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c1753f6d2dacb1942fbef156a075bc"></a><!-- doxytag: member="MPU6050::setMemoryBank" ref="aa0c1753f6d2dacb1942fbef156a075bc" args="(uint8_t bank, bool prefetchEnabled=false, bool userBank=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setMemoryBank</b> (uint8_t bank, bool prefetchEnabled=false, bool userBank=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45013abb39103e858d432cc720bc351a"></a><!-- doxytag: member="MPU6050::setMemoryStartAddress" ref="a45013abb39103e858d432cc720bc351a" args="(uint8_t address)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setMemoryStartAddress</b> (uint8_t address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb50ebcff2f4e686e3fbbafb70a1f75"></a><!-- doxytag: member="MPU6050::readMemoryByte" ref="a4fb50ebcff2f4e686e3fbbafb70a1f75" args="()" -->
uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>readMemoryByte</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20de45af9109402f0cfe785f8fdbf439"></a><!-- doxytag: member="MPU6050::writeMemoryByte" ref="a20de45af9109402f0cfe785f8fdbf439" args="(uint8_t data)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>writeMemoryByte</b> (uint8_t data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04d8d5e7b62605aed15f07f52afa74ca"></a><!-- doxytag: member="MPU6050::readMemoryBlock" ref="a04d8d5e7b62605aed15f07f52afa74ca" args="(uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>readMemoryBlock</b> (uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac68fd47ea637c2a98fa6dfc0ce3bdf70"></a><!-- doxytag: member="MPU6050::writeMemoryBlock" ref="ac68fd47ea637c2a98fa6dfc0ce3bdf70" args="(uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0, bool verify=true, bool useProgMem=false)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>writeMemoryBlock</b> (uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0, bool verify=true, bool useProgMem=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a574194426e934f2435c9930271447229"></a><!-- doxytag: member="MPU6050::writeProgMemoryBlock" ref="a574194426e934f2435c9930271447229" args="(uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0, bool verify=true)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>writeProgMemoryBlock</b> (uint8_t *data, uint16_t dataSize, uint8_t bank=0, uint8_t address=0, bool verify=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a421cdf4cea9fea87decbd69084ba4956"></a><!-- doxytag: member="MPU6050::getDMPConfig1" ref="a421cdf4cea9fea87decbd69084ba4956" args="()" -->
uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPConfig1</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0126b95e4074de16bb61d9c4e4cf837f"></a><!-- doxytag: member="MPU6050::setDMPConfig1" ref="a0126b95e4074de16bb61d9c4e4cf837f" args="(uint8_t config)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setDMPConfig1</b> (uint8_t config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29594027f88c291708a38fba67c4ecd5"></a><!-- doxytag: member="MPU6050::getDMPConfig2" ref="a29594027f88c291708a38fba67c4ecd5" args="()" -->
uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getDMPConfig2</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea90c3e6a6666f070f7833a913cfa821"></a><!-- doxytag: member="MPU6050::setDMPConfig2" ref="aea90c3e6a6666f070f7833a913cfa821" args="(uint8_t config)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setDMPConfig2</b> (uint8_t config)</td></tr>
</tbody></table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c0146d45537e4bd7a0d4c1c476fdab7"></a><!-- doxytag: member="MPU6050::MPU6050" ref="a7c0146d45537e4bd7a0d4c1c476fdab7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">MPU6050::MPU6050 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Default constructor, uses default I2C address. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_DEFAULT_ADDRESS </dd></dl>

</div>
</div>
<a class="anchor" id="a94df4ec1565317ba5279122b3bf7e056"></a><!-- doxytag: member="MPU6050::MPU6050" ref="a94df4ec1565317ba5279122b3bf7e056" args="(uint8_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">MPU6050::MPU6050 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Specific address constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">address</td><td>I2C address </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_DEFAULT_ADDRESS </dd>
<dd>
MPU6050_ADDRESS_AD0_LOW </dd>
<dd>
MPU6050_ADDRESS_AD0_HIGH </dd></dl>

</div>
</div>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" id="a658dfc7e35b7fdba360a75f137bde33a"></a><!-- doxytag: member="MPU6050::getAcceleration" ref="a658dfc7e35b7fdba360a75f137bde33a" args="(int16_t *x, int16_t *y, int16_t *z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::getAcceleration </td>
          <td>(</td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>z</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get 3-axis accelerometer readings. These registers store the most 
recent accelerometer measurements. Accelerometer measurements are 
written to these registers at the Sample Rate as defined in Register 25.</p>
<p>The accelerometer measurement registers, along with the temperature 
measurement registers, gyroscope measurement registers, and external 
sensor data registers, are composed of two sets of registers: an 
internal register set and a user-facing read register set.</p>
<p>The data within the accelerometer sensors' internal register set is 
always updated at the Sample Rate. Meanwhile, the user-facing read 
register set duplicates the internal register set's data values whenever
 the serial interface is idle. This guarantees that a burst read of 
sensor registers will read measurements from the same sampling instant. 
Note that if burst reads are not used, the user is responsible for 
ensuring a set of single byte reads correspond to a single sampling 
instant by checking the Data Ready interrupt.</p>
<p>Each 16-bit accelerometer measurement has a full scale defined in 
ACCEL_FS (Register 28). For each full scale setting, the accelerometers'
 sensitivity per LSB in ACCEL_xOUT is shown in the table below:</p>
<pre> AFS_SEL | Full Scale Range | LSB Sensitivity
 --------+------------------+----------------
 0       | +/- 2g           | 8192 LSB/mg
 1       | +/- 4g           | 4096 LSB/mg
 2       | +/- 8g           | 2048 LSB/mg
 3       | +/- 16g          | 1024 LSB/mg
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">x</td><td>16-bit signed integer container for X-axis acceleration </td></tr>
    <tr><td class="paramname">y</td><td>16-bit signed integer container for Y-axis acceleration </td></tr>
    <tr><td class="paramname">z</td><td>16-bit signed integer container for Z-axis acceleration </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_GYRO_XOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="aa68475158c22128e5459c4c5e19439dc"></a><!-- doxytag: member="MPU6050::getAccelerationX" ref="aa68475158c22128e5459c4c5e19439dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getAccelerationX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get X-axis accelerometer reading. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>X-axis acceleration measurement in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_ACCEL_XOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="a27240b90d3e03c85b7a619b794bb1756"></a><!-- doxytag: member="MPU6050::getAccelerationY" ref="a27240b90d3e03c85b7a619b794bb1756" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getAccelerationY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Y-axis accelerometer reading. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Y-axis acceleration measurement in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_ACCEL_YOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="acf5f5a20c10d99a1bdedf139f897bfdf"></a><!-- doxytag: member="MPU6050::getAccelerationZ" ref="acf5f5a20c10d99a1bdedf139f897bfdf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getAccelerationZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Z-axis accelerometer reading. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Z-axis acceleration measurement in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_ACCEL_ZOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="aae903df2accc687423f9cd0a78f9cd32"></a><!-- doxytag: member="MPU6050::getAccelerometerPowerOnDelay" ref="aae903df2accc687423f9cd0a78f9cd32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getAccelerometerPowerOnDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get accelerometer power-on delay. The accelerometer data path 
provides samples to the sensor registers, Motion detection, Zero Motion 
detection, and Free Fall detection modules. The signal path contains 
filters which must be flushed on wake-up with new samples before the 
detection modules begin operations. The default wake-up delay, of 4ms 
can be lengthened by up to 3ms. This additional delay is specified in 
ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select any value 
above zero unless instructed otherwise by InvenSense. Please refer to 
Section 8 of the MPU-6000/MPU-6050 Product Specification document for 
further information regarding the detection modules. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current accelerometer power-on delay </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_CTRL </dd>
<dd>
MPU6050_DETECT_ACCEL_ON_DELAY_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ace244415128ad7a38293ad6808b7face"></a><!-- doxytag: member="MPU6050::getAccelFIFOEnabled" ref="ace244415128ad7a38293ad6808b7face" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getAccelFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get accelerometer FIFO enabled value. When set to 1, this bit enables
 ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, 
and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO 
buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current accelerometer FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a8fc7eab1302281f6e4bc953379f3237b"></a><!-- doxytag: member="MPU6050::getAccelXSelfTest" ref="a8fc7eab1302281f6e4bc953379f3237b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getAccelXSelfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get self-test enabled setting for accelerometer X axis. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Self-test enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="a2523e798db3baf9cb9dbf347af16639b"></a><!-- doxytag: member="MPU6050::getAccelYSelfTest" ref="a2523e798db3baf9cb9dbf347af16639b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getAccelYSelfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get self-test enabled value for accelerometer Y axis. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Self-test enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="a57710638eeb6176cf14a8c444bda5300"></a><!-- doxytag: member="MPU6050::getAccelZSelfTest" ref="a57710638eeb6176cf14a8c444bda5300" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getAccelZSelfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get self-test enabled value for accelerometer Z axis. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Self-test enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="af6e9af8e2222889fd5458e2ae12c55c8"></a><!-- doxytag: member="MPU6050::getAuxVDDIOLevel" ref="af6e9af8e2222889fd5458e2ae12c55c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getAuxVDDIOLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the auxiliary I2C supply voltage level. When set to 1, the 
auxiliary I2C bus high logic level is VDD. When cleared to 0, the 
auxiliary I2C bus high logic level is VLOGIC. This does not apply to the
 MPU-6000, which does not have a VLOGIC pin. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>I2C supply voltage level (0=VLOGIC, 1=VDD) </dd></dl>

</div>
</div>
<a class="anchor" id="ada96c33957bf20c04ca598a3537358ef"></a><!-- doxytag: member="MPU6050::getClockOutputEnabled" ref="ada96c33957bf20c04ca598a3537358ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getClockOutputEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get reference clock output enabled status. When this bit is equal to 
1, a reference clock output is provided at the CLKOUT pin. When this bit
 is equal to 0, the clock output is disabled. For further information 
regarding CLKOUT, please refer to the MPU-60X0 Product Specification 
document. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current reference clock output enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_CLKOUT_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a8ed670258a805807b5102cdc5d0996a8"></a><!-- doxytag: member="MPU6050::getClockSource" ref="a8ed670258a805807b5102cdc5d0996a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getClockSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get clock source setting. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current clock source setting </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_CLKSEL_BIT </dd>
<dd>
MPU6050_PWR1_CLKSEL_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="a35ae3c8894b3258e642043886801e031"></a><!-- doxytag: member="MPU6050::getDeviceID" ref="a35ae3c8894b3258e642043886801e031" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getDeviceID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Device ID. This register is used to verify the identity of the device (0b110100). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Device ID (should be 0x68, 104 dec, 150 oct) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_WHO_AM_I </dd>
<dd>
MPU6050_WHO_AM_I_BIT </dd>
<dd>
MPU6050_WHO_AM_I_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="a4c3b84a906fcb5a65870fa557f797f4a"></a><!-- doxytag: member="MPU6050::getDHPFMode" ref="a4c3b84a906fcb5a65870fa557f797f4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getDHPFMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the high-pass filter configuration. The DHPF is a filter module 
in the path leading to motion detectors (Free Fall, Motion threshold, 
and Zero Motion). The high pass filter output is not available to the 
data registers (see Figure in Section 8 of the MPU-6000/ MPU-6050 
Product Specification document).</p>
<p>The high pass filter has three modes:</p>
<pre>    Reset: The filter output settles to zero within one sample. This
           effectively disables the high pass filter. This mode may be toggled
           to quickly settle the filter.</pre><pre>    On:    The high pass filter will pass signals above the cut off frequency.</pre><pre>    Hold:  When triggered, the filter holds the present sample. The filter
           output will be the difference between the input sample and the held
           sample.
 </pre><pre> ACCEL_HPF | Filter Mode | Cut-off Frequency
 ----------+-------------+------------------
 0         | Reset       | None
 1         | On          | 5Hz
 2         | On          | 2.5Hz
 3         | On          | 1.25Hz
 4         | On          | 0.63Hz
 7         | Hold        | None
 </pre><dl class="return"><dt><b>Returns:</b></dt><dd>Current high-pass filter configuration </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_DHPF_RESET </dd>
<dd>
MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="a9f2737fe22955fd85b2575ba8da874c6"></a><!-- doxytag: member="MPU6050::getDLPFMode" ref="a9f2737fe22955fd85b2575ba8da874c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getDLPFMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get digital low-pass filter configuration. The DLPF_CFG parameter 
sets the digital low pass filter configuration. It also determines the 
internal sampling rate used by the device as shown in the table below.</p>
<p>Note: The accelerometer output rate is 1kHz. This means that for a 
Sample Rate greater than 1kHz, the same accelerometer sample may be 
output to the FIFO, DMP, and sensor registers more than once.</p>
<pre>          |   ACCELEROMETER    |           GYROSCOPE
 DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
 ---------+-----------+--------+-----------+--------+-------------
 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
 7        |   -- Reserved --   |   -- Reserved --   | Reserved
 </pre><dl class="return"><dt><b>Returns:</b></dt><dd>DLFP configuration </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_CONFIG </dd>
<dd>
MPU6050_CFG_DLPF_CFG_BIT </dd>
<dd>
MPU6050_CFG_DLPF_CFG_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="a902a7d486cd6ac21f8c378634dc6f59a"></a><!-- doxytag: member="MPU6050::getExternalFrameSync" ref="a902a7d486cd6ac21f8c378634dc6f59a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getExternalFrameSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get external FSYNC configuration. Configures the external Frame 
Synchronization (FSYNC) pin sampling. An external signal connected to 
the FSYNC pin can be sampled by configuring EXT_SYNC_SET. Signal changes
 to the FSYNC pin are latched so that short strobes may be captured. The
 latched FSYNC signal will be sampled at the Sampling Rate, as defined 
in register 25. After sampling, the latch will reset to the current 
FSYNC signal state.</p>
<p>The sampled value will be reported in place of the least significant 
bit in a sensor data register determined by the value of EXT_SYNC_SET 
according to the following table.</p>
<pre> EXT_SYNC_SET | FSYNC Bit Location
 -------------+-------------------
 0            | Input disabled
 1            | TEMP_OUT_L[0]
 2            | GYRO_XOUT_L[0]
 3            | GYRO_YOUT_L[0]
 4            | GYRO_ZOUT_L[0]
 5            | ACCEL_XOUT_L[0]
 6            | ACCEL_YOUT_L[0]
 7            | ACCEL_ZOUT_L[0]
 </pre><dl class="return"><dt><b>Returns:</b></dt><dd>FSYNC configuration value </dd></dl>

</div>
</div>
<a class="anchor" id="a7f786ab4264f40e5a95e8937ec9adcc2"></a><!-- doxytag: member="MPU6050::getExternalSensorByte" ref="a7f786ab4264f40e5a95e8937ec9adcc2" args="(int position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getExternalSensorByte </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Read single byte from external sensor data register. These registers 
store data read from external sensors by the Slave 0, 1, 2, and 3 on the
 auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI 
(Register 53).</p>
<p>External sensor data is written to these registers at the Sample Rate
 as defined in Register 25. This access rate can be reduced by using the
 Slave Delay Enable registers (Register 103).</p>
<p>External sensor data registers, along with the gyroscope measurement 
registers, accelerometer measurement registers, and temperature 
measurement registers, are composed of two sets of registers: an 
internal register set and a user-facing read register set.</p>
<p>The data within the external sensors' internal register set is always
 updated at the Sample Rate (or the reduced access rate) whenever the 
serial interface is idle. This guarantees that a burst read of sensor 
registers will read measurements from the same sampling instant. Note 
that if burst reads are not used, the user is responsible for ensuring a
 set of single byte reads correspond to a single sampling instant by 
checking the Data Ready interrupt.</p>
<p>Data is placed in these external sensor data registers according to 
I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL 
(Registers 39, 42, 45, and 48). When more than zero bytes are read 
(I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave
 is read at the Sample Rate (as defined in Register 25) or delayed rate 
(if specified in Register 52 and 103). During each Sample cycle, slave 
reads are performed in order of Slave number. If all slaves are enabled 
with more than zero bytes to be read, the order will be Slave 0, 
followed by Slave 1, Slave 2, and Slave 3.</p>
<p>Each enabled slave will have EXT_SENS_DATA registers associated with 
it by number of bytes read (I2C_SLVx_LEN) in order of slave number, 
starting from EXT_SENS_DATA_00. Note that this means enabling or 
disabling a slave may change the higher numbered slaves' associated 
registers. Furthermore, if fewer total bytes are being read from the 
external sensors as a result of such a change, then the data remaining 
in the registers which no longer have an associated slave device (i.e. 
high numbered registers) will remain in these previously allocated 
registers unless reset.</p>
<p>If the sum of the read lengths of all SLVx transactions exceed the 
number of available EXT_SENS_DATA registers, the excess bytes will be 
dropped. There are 24 EXT_SENS_DATA registers and hence the total read 
lengths between all the slaves cannot be greater than 24 or some bytes 
will be lost.</p>
<p>Note: Slave 4's behavior is distinct from that of Slaves 0-3. For 
further information regarding the characteristics of Slave 4, please 
refer to Registers 49 to 53.</p>
<p>EXAMPLE: Suppose that Slave 0 is enabled with 4 bytes to be read 
(I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 
bytes to be read so that I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a
 situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 
0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1. If 
Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 
will be allocated to Slave 2.</p>
<p>If Slave 2 is disabled while Slave 3 is enabled in this same 
situation, then registers starting from EXT_SENS_DATA_06 will be 
allocated to Slave 3 instead.</p>
<p>REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE: If a 
slave is disabled at any time, the space initially allocated to the 
slave in the EXT_SENS_DATA register, will remain associated with that 
slave. This is to avoid dynamic adjustment of the register allocation.</p>
<p>The allocation of the EXT_SENS_DATA registers is recomputed only when
 (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set 
(Register 106).</p>
<p>This above is also true if one of the slaves gets NACKed and stops functioning.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">position</td><td>Starting position (0-23) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Byte read from register </dd></dl>

</div>
</div>
<a class="anchor" id="afd8983f0911e37015434bebc85185fb2"></a><!-- doxytag: member="MPU6050::getExternalSensorDWord" ref="afd8983f0911e37015434bebc85185fb2" args="(int position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint32_t MPU6050::getExternalSensorDWord </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Read double word (4 bytes) from external sensor data registers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">position</td><td>Starting position (0-20) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Double word read from registers </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7f786ab4264f40e5a95e8937ec9adcc2">getExternalSensorByte()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaee15e48af7ba78660b5754f3bb5f37a"></a><!-- doxytag: member="MPU6050::getExternalSensorWord" ref="aaee15e48af7ba78660b5754f3bb5f37a" args="(int position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t MPU6050::getExternalSensorWord </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Read word (2 bytes) from external sensor data registers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">position</td><td>Starting position (0-21) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Word read from register </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7f786ab4264f40e5a95e8937ec9adcc2">getExternalSensorByte()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e5cb13838298609b5260fd1558f8c92"></a><!-- doxytag: member="MPU6050::getExternalShadowDelayEnabled" ref="a0e5cb13838298609b5260fd1558f8c92" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getExternalShadowDelayEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get external data shadow delay enabled status. This register is used 
to specify the timing of external sensor data shadowing. When 
DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is 
delayed until all data has been received. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current external data shadow delay enabled status. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_DELAY_CTRL </dd>
<dd>
MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a7733011d30d5b64564f6b5422d8639ae"></a><!-- doxytag: member="MPU6050::getFIFOByte" ref="a7733011d30d5b64564f6b5422d8639ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getFIFOByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get byte from FIFO buffer. This register is used to read and write 
data from the FIFO buffer. Data is written to the FIFO in order of 
register number (from lowest to highest). If all the FIFO enable flags 
(see below) are enabled and all External Sensor Data registers 
(Registers 73 to 96) are associated with a Slave device, the contents of
 registers 59 through 96 will be written in order at the Sample Rate.</p>
<p>The contents of the sensor data registers (Registers 59 to 96) are 
written into the FIFO buffer when their corresponding FIFO enable flags 
are set to 1 in FIFO_EN (Register 35). An additional flag for the sensor
 data registers associated with I2C Slave 3 can be found in I2C_MST_CTRL
 (Register 36).</p>
<p>If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is 
automatically set to 1. This bit is located in INT_STATUS (Register 58).
 When the FIFO buffer has overflowed, the oldest data will be lost and 
new data will be written to the FIFO.</p>
<p>If the FIFO buffer is empty, reading this register will return the 
last byte that was previously read from the FIFO until new data is 
available. The user should check FIFO_COUNT to ensure that the FIFO 
buffer is not read when empty.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Byte from FIFO buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ad96c7a75a39327ebaae01386bcbc58dd"></a><!-- doxytag: member="MPU6050::getFIFOCount" ref="ad96c7a75a39327ebaae01386bcbc58dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint16_t MPU6050::getFIFOCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get current FIFO buffer size. This value indicates the number of 
bytes stored in the FIFO buffer. This number is in turn the number of 
bytes that can be read from the FIFO buffer and it is directly 
proportional to the number of samples available given the set of sensor 
data bound to be stored in the FIFO (register 35 and 36). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current FIFO buffer size </dd></dl>

</div>
</div>
<a class="anchor" id="ae2687a09ebe0d7fbbf74f560e0dd9a44"></a><!-- doxytag: member="MPU6050::getFIFOEnabled" ref="ae2687a09ebe0d7fbbf74f560e0dd9a44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get FIFO enabled status. When this bit is set to 0, the FIFO buffer 
is disabled. The FIFO buffer cannot be written to or read from while 
disabled. The FIFO buffer's state does not change unless the MPU-60X0 is
 power cycled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current FIFO enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_FIFO_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="af6d6fa9869636989a8b29c4827ad7de8"></a><!-- doxytag: member="MPU6050::getFreefallDetectionCounterDecrement" ref="af6d6fa9869636989a8b29c4827ad7de8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getFreefallDetectionCounterDecrement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Free Fall detection counter decrement configuration. Detection is
 registered by the Free Fall detection module after accelerometer 
measurements meet their respective threshold conditions over a specified
 number of samples. When the threshold conditions are met, the 
corresponding detection counter increments by 1. The user may control 
the rate at which the detection counter decrements when the threshold 
condition is not met by configuring FF_COUNT. The decrement rate can be 
set according to the following table:</p>
<pre> FF_COUNT | Counter Decrement
 ---------+------------------
 0        | Reset
 1        | 1
 2        | 2
 3        | 4
 </pre><p>When FF_COUNT is configured to 0 (reset), any non-qualifying 
sample will reset the counter to 0. For further information on Free Fall
 detection, please refer to Registers 29 to 32.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current decrement configuration </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_CTRL </dd>
<dd>
MPU6050_DETECT_FF_COUNT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a3cff6b9613ad01aa1a51c287f5c5e329"></a><!-- doxytag: member="MPU6050::getFreefallDetectionDuration" ref="a3cff6b9613ad01aa1a51c287f5c5e329" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getFreefallDetectionDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get free-fall event duration threshold. This register configures the 
duration counter threshold for Free Fall event detection. The duration 
counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms.</p>
<p>The Free Fall duration counter increments while the absolute value of
 the accelerometer measurements are each less than the detection 
threshold (Register 29). The Free Fall interrupt is triggered when the 
Free Fall duration counter reaches the time specified in this register.</p>
<p>For more details on the Free Fall detection interrupt, see Section 
8.2 of the MPU-6000/MPU-6050 Product Specification document as well as 
Registers 56 and 58 of this document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current free-fall duration threshold value (LSB = 1ms) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FF_DUR </dd></dl>

</div>
</div>
<a class="anchor" id="ac7f5c0511fe9d0f3525a3757498daed7"></a><!-- doxytag: member="MPU6050::getFreefallDetectionThreshold" ref="ac7f5c0511fe9d0f3525a3757498daed7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getFreefallDetectionThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get free-fall event acceleration threshold. This register configures 
the detection threshold for Free Fall event detection. The unit of 
FF_THR is 1LSB = 2mg. Free Fall is detected when the absolute value of 
the accelerometer measurements for the three axes are each less than the
 detection threshold. This condition increments the Free Fall duration 
counter (Register 30). The Free Fall interrupt is triggered when the 
Free Fall duration counter reaches the time specified in FF_DUR.</p>
<p>For more details on the Free Fall detection interrupt, see Section 
8.2 of the MPU-6000/MPU-6050 Product Specification document as well as 
Registers 56 and 58 of this document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current free-fall acceleration threshold value (LSB = 2mg) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FF_THR </dd></dl>

</div>
</div>
<a class="anchor" id="a4c01f9ab83b64dbbc6b62e658c3d3d9b"></a><!-- doxytag: member="MPU6050::getFSyncInterruptEnabled" ref="a4c01f9ab83b64dbbc6b62e658c3d3d9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getFSyncInterruptEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get FSYNC pin interrupt enabled setting. Will be set 0 for disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled setting </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_FSYNC_INT_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a60fc85d4f27f99d07ffb9543d5e5f347"></a><!-- doxytag: member="MPU6050::getFSyncInterruptLevel" ref="a60fc85d4f27f99d07ffb9543d5e5f347" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getFSyncInterruptLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get FSYNC interrupt logic level mode. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current FSYNC interrupt mode (0=active-high, 1=active-low) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getFSyncInterruptMode() </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a0fe2dad60c170cee7d614e08f243ffd0"></a><!-- doxytag: member="MPU6050::getFullScaleAccelRange" ref="a0fe2dad60c170cee7d614e08f243ffd0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getFullScaleAccelRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get full-scale accelerometer range. The FS_SEL parameter allows 
setting the full-scale range of the accelerometer sensors, as described 
in the table below.</p>
<pre> 0 = +/- 2g
 1 = +/- 4g
 2 = +/- 8g
 3 = +/- 16g
 </pre><dl class="return"><dt><b>Returns:</b></dt><dd>Current full-scale accelerometer range setting </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_ACCEL_FS_2 </dd>
<dd>
MPU6050_RA_ACCEL_CONFIG </dd>
<dd>
MPU6050_ACONFIG_AFS_SEL_BIT </dd>
<dd>
MPU6050_ACONFIG_AFS_SEL_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="acb1fa088d43d76230106a3226f343013"></a><!-- doxytag: member="MPU6050::getFullScaleGyroRange" ref="acb1fa088d43d76230106a3226f343013" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getFullScaleGyroRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get full-scale gyroscope range. The FS_SEL parameter allows setting 
the full-scale range of the gyro sensors, as described in the table 
below.</p>
<pre> 0 = +/- 250 degrees/sec
 1 = +/- 500 degrees/sec
 2 = +/- 1000 degrees/sec
 3 = +/- 2000 degrees/sec
 </pre><dl class="return"><dt><b>Returns:</b></dt><dd>Current full-scale gyroscope range setting </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_GYRO_FS_250 </dd>
<dd>
MPU6050_RA_GYRO_CONFIG </dd>
<dd>
MPU6050_GCONFIG_FS_SEL_BIT </dd>
<dd>
MPU6050_GCONFIG_FS_SEL_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="aed33db318a770d0020eb8b84058650f3"></a><!-- doxytag: member="MPU6050::getI2CBypassEnabled" ref="aed33db318a770d0020eb8b84058650f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getI2CBypassEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get I2C bypass enabled status. When this bit is equal to 1 and 
I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application 
processor will be able to directly access the auxiliary I2C bus of the 
MPU-60X0. When this bit is equal to 0, the host application processor 
will not be able to directly access the auxiliary I2C bus of the 
MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current I2C bypass enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_I2C_BYPASS_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a6b45e538f2082eb1b1975ed56e3e21bc"></a><!-- doxytag: member="MPU6050::getI2CMasterModeEnabled" ref="a6b45e538f2082eb1b1975ed56e3e21bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getI2CMasterModeEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get I2C Master Mode enabled status. When this mode is enabled, the 
MPU-60X0 acts as the I2C Master to the external sensor slave devices on 
the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary I2C 
bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C 
bus (SDA and SCL). This is a precondition to enabling Bypass Mode. For 
further information regarding Bypass Mode, please refer to Register 55. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current I2C Master Mode enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_I2C_MST_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ae15f6043a74c9c9bf9754824802ce8d3"></a><!-- doxytag: member="MPU6050::getIntDataReadyEnabled" ref="ae15f6043a74c9c9bf9754824802ce8d3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntDataReadyEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Data Ready interrupt enabled setting. This event occurs each time
 a write operation to all of the sensor registers has been completed. 
Will be set 0 for disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_DATA_RDY_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ae4f434eb51a15b536e2e8f89a776872b"></a><!-- doxytag: member="MPU6050::getIntDataReadyStatus" ref="ae4f434eb51a15b536e2e8f89a776872b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntDataReadyStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Data Ready interrupt status. This bit automatically sets to 1 
when a Data Ready interrupt has been generated. The bit clears to 0 
after the register has been read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_STATUS </dd>
<dd>
MPU6050_INTERRUPT_DATA_RDY_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="af66e6c7b1885dcf452e73371790fddfd"></a><!-- doxytag: member="MPU6050::getInterruptDrive" ref="af66e6c7b1885dcf452e73371790fddfd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getInterruptDrive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get interrupt drive mode. Will be set 0 for push-pull, 1 for open-drain. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt drive mode (0=push-pull, 1=open-drain) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_INT_OPEN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a5502c4c2a9bc4ea9267e128b7743923d"></a><!-- doxytag: member="MPU6050::getInterruptLatch" ref="a5502c4c2a9bc4ea9267e128b7743923d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getInterruptLatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get interrupt latch mode. Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current latch mode (0=50us-pulse, 1=latch-until-int-cleared) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_LATCH_INT_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a9a098a607e20c64b60e155da35b8264f"></a><!-- doxytag: member="MPU6050::getInterruptLatchClear" ref="a9a098a607e20c64b60e155da35b8264f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getInterruptLatchClear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get interrupt latch clear mode. Will be set 0 for status-read-only, 1 for any-register-read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current latch clear mode (0=status-read-only, 1=any-register-read) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_INT_RD_CLEAR_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a58da1dfb39eb34e3a09a9b0bf4d87f29"></a><!-- doxytag: member="MPU6050::getInterruptMode" ref="a58da1dfb39eb34e3a09a9b0bf4d87f29" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getInterruptMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get interrupt logic level mode. Will be set 0 for active-high, 1 for active-low. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt mode (0=active-high, 1=active-low) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_INT_LEVEL_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a55f99c88cc84901f245924ed5e3fe47e"></a><!-- doxytag: member="MPU6050::getIntFIFOBufferOverflowEnabled" ref="a55f99c88cc84901f245924ed5e3fe47e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntFIFOBufferOverflowEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get FIFO Buffer Overflow interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_FIFO_OFLOW_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="aa31427588f059c69d93ddb00ba257b12"></a><!-- doxytag: member="MPU6050::getIntFIFOBufferOverflowStatus" ref="aa31427588f059c69d93ddb00ba257b12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntFIFOBufferOverflowStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get FIFO Buffer Overflow interrupt status. This bit automatically 
sets to 1 when a Free Fall interrupt has been generated. The bit clears 
to 0 after the register has been read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_STATUS </dd>
<dd>
MPU6050_INTERRUPT_FIFO_OFLOW_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a500bb2df2e46eaecd3fb2ba7304a5ed3"></a><!-- doxytag: member="MPU6050::getIntFreefallEnabled" ref="a500bb2df2e46eaecd3fb2ba7304a5ed3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntFreefallEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Free Fall interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_FF_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a06bbc2116235b7cc5e28c877e0576749"></a><!-- doxytag: member="MPU6050::getIntFreefallStatus" ref="a06bbc2116235b7cc5e28c877e0576749" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntFreefallStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Free Fall interrupt status. This bit automatically sets to 1 when
 a Free Fall interrupt has been generated. The bit clears to 0 after the
 register has been read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_STATUS </dd>
<dd>
MPU6050_INTERRUPT_FF_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a282ae29e029d88604a59c92bdf9ce252"></a><!-- doxytag: member="MPU6050::getIntI2CMasterEnabled" ref="a282ae29e029d88604a59c92bdf9ce252" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntI2CMasterEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get I2C Master interrupt enabled status. This enables any of the I2C 
Master interrupt sources to generate an interrupt. Will be set 0 for 
disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_I2C_MST_INT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a31d6c2b03fc2d6ce82d67d142f316851"></a><!-- doxytag: member="MPU6050::getIntI2CMasterStatus" ref="a31d6c2b03fc2d6ce82d67d142f316851" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntI2CMasterStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get I2C Master interrupt status. This bit automatically sets to 1 
when an I2C Master interrupt has been generated. For a list of I2C 
Master interrupts, please refer to Register 54. The bit clears to 0 
after the register has been read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_STATUS </dd>
<dd>
MPU6050_INTERRUPT_I2C_MST_INT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a7de31a8e9f22765329d9f9e02db2f1f0"></a><!-- doxytag: member="MPU6050::getIntMotionEnabled" ref="a7de31a8e9f22765329d9f9e02db2f1f0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntMotionEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_MOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ac0c0836aa0d237cac92d11591efd0d9f"></a><!-- doxytag: member="MPU6050::getIntMotionStatus" ref="ac0c0836aa0d237cac92d11591efd0d9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntMotionStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Motion Detection interrupt status. This bit automatically sets to
 1 when a Motion Detection interrupt has been generated. The bit clears 
to 0 after the register has been read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_STATUS </dd>
<dd>
MPU6050_INTERRUPT_MOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ab3cc9bcaca6cec61e7f3f0c6c8a37db5"></a><!-- doxytag: member="MPU6050::getIntZeroMotionEnabled" ref="ab3cc9bcaca6cec61e7f3f0c6c8a37db5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntZeroMotionEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Zero Motion Detection interrupt enabled status. Will be set 0 for disabled, 1 for enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_ZMOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="afa73a5ffdc423736ae88702a469ba3a0"></a><!-- doxytag: member="MPU6050::getIntZeroMotionStatus" ref="afa73a5ffdc423736ae88702a469ba3a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getIntZeroMotionStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Zero Motion Detection interrupt status. This bit automatically 
sets to 1 when a Zero Motion Detection interrupt has been generated. The
 bit clears to 0 after the register has been read. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_STATUS </dd>
<dd>
MPU6050_INTERRUPT_ZMOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="acd775c72f85dabfc6f8fba43da096c6d"></a><!-- doxytag: member="MPU6050::getLostArbitration" ref="acd775c72f85dabfc6f8fba43da096c6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getLostArbitration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get master arbitration lost status. This bit automatically sets to 1 
when the I2C Master has lost arbitration of the auxiliary I2C bus (an 
error condition). This triggers an interrupt if the I2C_MST_INT_EN bit 
in the INT_ENABLE register (Register 56) is asserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Master arbitration lost status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a4cda448ef5c5736bd14188947342d636"></a><!-- doxytag: member="MPU6050::getMasterClockSpeed" ref="a4cda448ef5c5736bd14188947342d636" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getMasterClockSpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get I2C master clock speed. I2C_MST_CLK is a 4 bit unsigned value 
which configures a divider on the MPU-60X0 internal 8MHz clock. It sets 
the I2C master clock speed according to the following table:</p>
<pre> I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider
 ------------+------------------------+-------------------
 0           | 348kHz                 | 23
 1           | 333kHz                 | 24
 2           | 320kHz                 | 25
 3           | 308kHz                 | 26
 4           | 296kHz                 | 27
 5           | 286kHz                 | 28
 6           | 276kHz                 | 29
 7           | 267kHz                 | 30
 8           | 258kHz                 | 31
 9           | 500kHz                 | 16
 10          | 471kHz                 | 17
 11          | 444kHz                 | 18
 12          | 421kHz                 | 19
 13          | 400kHz                 | 20
 14          | 381kHz                 | 21
 15          | 364kHz                 | 22
 </pre><dl class="return"><dt><b>Returns:</b></dt><dd>Current I2C master clock speed </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a574d3093dc131e4251a9b37adf208ca7"></a><!-- doxytag: member="MPU6050::getMotion6" ref="a574d3093dc131e4251a9b37adf208ca7" args="(int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::getMotion6 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>gx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>gy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>gz</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get raw 6-axis motion sensor readings (accel/gyro). Retrieves all currently available motion sensor values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ax</td><td>16-bit signed integer container for accelerometer X-axis value </td></tr>
    <tr><td class="paramname">ay</td><td>16-bit signed integer container for accelerometer Y-axis value </td></tr>
    <tr><td class="paramname">az</td><td>16-bit signed integer container for accelerometer Z-axis value </td></tr>
    <tr><td class="paramname">gx</td><td>16-bit signed integer container for gyroscope X-axis value </td></tr>
    <tr><td class="paramname">gy</td><td>16-bit signed integer container for gyroscope Y-axis value </td></tr>
    <tr><td class="paramname">gz</td><td>16-bit signed integer container for gyroscope Z-axis value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a658dfc7e35b7fdba360a75f137bde33a">getAcceleration()</a> </dd>
<dd>
<a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ca85b87e7e0230921062fce7889b0d1">getRotation()</a> </dd>
<dd>
MPU6050_RA_ACCEL_XOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="aabfd2920e748016383e8124a4b32ad31"></a><!-- doxytag: member="MPU6050::getMotion9" ref="aabfd2920e748016383e8124a4b32ad31" args="(int16_t *ax, int16_t *ay, int16_t *az, int16_t *gx, int16_t *gy, int16_t *gz, int16_t *mx, int16_t *my, int16_t *mz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::getMotion9 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>gx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>gy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>gz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>mz</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get raw 9-axis motion sensor readings (accel/gyro/compass). FUNCTION NOT FULLY IMPLEMENTED YET. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">ax</td><td>16-bit signed integer container for accelerometer X-axis value </td></tr>
    <tr><td class="paramname">ay</td><td>16-bit signed integer container for accelerometer Y-axis value </td></tr>
    <tr><td class="paramname">az</td><td>16-bit signed integer container for accelerometer Z-axis value </td></tr>
    <tr><td class="paramname">gx</td><td>16-bit signed integer container for gyroscope X-axis value </td></tr>
    <tr><td class="paramname">gy</td><td>16-bit signed integer container for gyroscope Y-axis value </td></tr>
    <tr><td class="paramname">gz</td><td>16-bit signed integer container for gyroscope Z-axis value </td></tr>
    <tr><td class="paramname">mx</td><td>16-bit signed integer container for magnetometer X-axis value </td></tr>
    <tr><td class="paramname">my</td><td>16-bit signed integer container for magnetometer Y-axis value </td></tr>
    <tr><td class="paramname">mz</td><td>16-bit signed integer container for magnetometer Z-axis value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
<a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a658dfc7e35b7fdba360a75f137bde33a">getAcceleration()</a> </dd>
<dd>
<a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ca85b87e7e0230921062fce7889b0d1">getRotation()</a> </dd>
<dd>
MPU6050_RA_ACCEL_XOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed8de8eb440dbfdec829297527b0da6"></a><!-- doxytag: member="MPU6050::getMotionDetectionCounterDecrement" ref="a0ed8de8eb440dbfdec829297527b0da6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getMotionDetectionCounterDecrement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Motion detection counter decrement configuration. Detection is 
registered by the Motion detection module after accelerometer 
measurements meet their respective threshold conditions over a specified
 number of samples. When the threshold conditions are met, the 
corresponding detection counter increments by 1. The user may control 
the rate at which the detection counter decrements when the threshold 
condition is not met by configuring MOT_COUNT. The decrement rate can be
 set according to the following table:</p>
<pre> MOT_COUNT | Counter Decrement
 ----------+------------------
 0         | Reset
 1         | 1
 2         | 2
 3         | 4
 </pre><p>When MOT_COUNT is configured to 0 (reset), any non-qualifying 
sample will reset the counter to 0. For further information on Motion 
detection, please refer to Registers 29 to 32. </p>

</div>
</div>
<a class="anchor" id="a8ba035c2ae4a05d7e51b0d29e4924fb0"></a><!-- doxytag: member="MPU6050::getMotionDetectionDuration" ref="a8ba035c2ae4a05d7e51b0d29e4924fb0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getMotionDetectionDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get motion detection event duration threshold. This register 
configures the duration counter threshold for Motion interrupt 
generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a
 unit of 1LSB = 1ms. The Motion detection duration counter increments 
when the absolute value of any of the accelerometer measurements exceeds
 the Motion detection threshold (Register 31). The Motion detection 
interrupt is triggered when the Motion detection counter reaches the 
time count specified in this register.</p>
<p>For more details on the Motion detection interrupt, see Section 8.3 of the MPU-6000/MPU-6050 Product Specification document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current motion detection duration threshold value (LSB = 1ms) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DUR </dd></dl>

</div>
</div>
<a class="anchor" id="ab7a825b1b8b86cebda308289630795e7"></a><!-- doxytag: member="MPU6050::getMotionDetectionThreshold" ref="ab7a825b1b8b86cebda308289630795e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getMotionDetectionThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get motion detection event acceleration threshold. This register 
configures the detection threshold for Motion interrupt generation. The 
unit of MOT_THR is 1LSB = 2mg. Motion is detected when the absolute 
value of any of the accelerometer measurements exceeds this Motion 
detection threshold. This condition increments the Motion detection 
duration counter (Register 32). The Motion detection interrupt is 
triggered when the Motion Detection counter reaches the time count 
specified in MOT_DUR (Register 32).</p>
<p>The Motion interrupt will indicate the axis and polarity of detected motion in MOT_DETECT_STATUS (Register 97).</p>
<p>For more details on the Motion detection interrupt, see Section 8.3 
of the MPU-6000/MPU-6050 Product Specification document as well as 
Registers 56 and 58 of this document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current motion detection acceleration threshold value (LSB = 2mg) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_THR </dd></dl>

</div>
</div>
<a class="anchor" id="aa88483068837bd9bc9c9f6c59a7a79b7"></a><!-- doxytag: member="MPU6050::getMultiMasterEnabled" ref="aa88483068837bd9bc9c9f6c59a7a79b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getMultiMasterEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get multi-master enabled value. Multi-master capability allows 
multiple I2C masters to operate on the same bus. In circuits where 
multi-master capability is required, set MULT_MST_EN to 1. This will 
increase current drawn by approximately 30uA.</p>
<p>In circuits where multi-master capability is required, the state of 
the I2C bus must always be monitored by each separate I2C Master. Before
 an I2C Master can assume arbitration of the bus, it must first confirm 
that no other I2C Master has arbitration of the bus. When MULT_MST_EN is
 set to 1, the MPU-60X0's bus arbitration detection logic is turned on, 
enabling it to detect when the bus is available.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current multi-master enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="af2820067b73f177d985ed81e894281b0"></a><!-- doxytag: member="MPU6050::getPassthroughStatus" ref="af2820067b73f177d985ed81e894281b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getPassthroughStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get FSYNC interrupt status. This bit reflects the status of the FSYNC
 interrupt from an external device into the MPU-60X0. This is used as a 
way to pass an external interrupt through the MPU-60X0 to the host 
application processor. When set to 1, this bit will cause an interrupt 
if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>FSYNC interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a887a173e079980505763ffd1aa9fec05"></a><!-- doxytag: member="MPU6050::getRate" ref="a887a173e079980505763ffd1aa9fec05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get gyroscope output rate divider. The sensor register output, FIFO 
output, DMP sampling, Motion detection, Zero Motion detection, and Free 
Fall detection are all based on the Sample Rate. The Sample Rate is 
generated by dividing the gyroscope output rate by SMPLRT_DIV:</p>
<p>Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)</p>
<p>where Gyroscope Output Rate = 8kHz when the DLPF is disabled 
(DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 
26).</p>
<p>Note: The accelerometer output rate is 1kHz. This means that for a 
Sample Rate greater than 1kHz, the same accelerometer sample may be 
output to the FIFO, DMP, and sensor registers more than once.</p>
<p>For a diagram of the gyroscope and accelerometer signal paths, see 
Section 8 of the MPU-6000/MPU-6050 Product Specification document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current sample rate </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_SMPLRT_DIV </dd></dl>

</div>
</div>
<a class="anchor" id="a8ca85b87e7e0230921062fce7889b0d1"></a><!-- doxytag: member="MPU6050::getRotation" ref="a8ca85b87e7e0230921062fce7889b0d1" args="(int16_t *x, int16_t *y, int16_t *z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::getRotation </td>
          <td>(</td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"><em>z</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get 3-axis gyroscope readings. These gyroscope measurement registers,
 along with the accelerometer measurement registers, temperature 
measurement registers, and external sensor data registers, are composed 
of two sets of registers: an internal register set and a user-facing 
read register set. The data within the gyroscope sensors' internal 
register set is always updated at the Sample Rate. Meanwhile, the 
user-facing read register set duplicates the internal register set's 
data values whenever the serial interface is idle. This guarantees that a
 burst read of sensor registers will read measurements from the same 
sampling instant. Note that if burst reads are not used, the user is 
responsible for ensuring a set of single byte reads correspond to a 
single sampling instant by checking the Data Ready interrupt.</p>
<p>Each 16-bit gyroscope measurement has a full scale defined in FS_SEL 
(Register 27). For each full scale setting, the gyroscopes' sensitivity 
per LSB in GYRO_xOUT is shown in the table below:</p>
<pre> FS_SEL | Full Scale Range   | LSB Sensitivity
 -------+--------------------+----------------
 0      | +/- 250 degrees/s  | 131 LSB/deg/s
 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s
 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s
 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">x</td><td>16-bit signed integer container for X-axis rotation </td></tr>
    <tr><td class="paramname">y</td><td>16-bit signed integer container for Y-axis rotation </td></tr>
    <tr><td class="paramname">z</td><td>16-bit signed integer container for Z-axis rotation </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_GYRO_XOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="a268f52843a24992ff06a3f12392de584"></a><!-- doxytag: member="MPU6050::getRotationX" ref="a268f52843a24992ff06a3f12392de584" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getRotationX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get X-axis gyroscope reading. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>X-axis rotation measurement in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_GYRO_XOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="a97cbe7f10dd27e07bd78d1c25e4286b5"></a><!-- doxytag: member="MPU6050::getRotationY" ref="a97cbe7f10dd27e07bd78d1c25e4286b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getRotationY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Y-axis gyroscope reading. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Y-axis rotation measurement in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_GYRO_YOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="ae0fee1ba996a2b6f914df6fc34e7da48"></a><!-- doxytag: member="MPU6050::getRotationZ" ref="ae0fee1ba996a2b6f914df6fc34e7da48" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getRotationZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Z-axis gyroscope reading. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Z-axis rotation measurement in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a574d3093dc131e4251a9b37adf208ca7">getMotion6()</a> </dd>
<dd>
MPU6050_RA_GYRO_ZOUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="a9bc93f34bc3d85cbe6010b4a3a88c5a7"></a><!-- doxytag: member="MPU6050::getSlate4InputByte" ref="a9bc93f34bc3d85cbe6010b4a3a88c5a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlate4InputByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get last available byte read from Slave 4. This register stores the 
data read from Slave 4. This field is populated after a read 
transaction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Last available byte read from to Slave 4 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_DI </dd></dl>

</div>
</div>
<a class="anchor" id="a6aa7aa2e3fac06f8b5ab9ee127255a5e"></a><!-- doxytag: member="MPU6050::getSlave0FIFOEnabled" ref="a6aa7aa2e3fac06f8b5ab9ee127255a5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave0FIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 0 FIFO enabled value. When set to 1, this bit enables 
EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to 
be written into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Slave 0 FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a74511edfcada3fb21c3327a0c846c72a"></a><!-- doxytag: member="MPU6050::getSlave0Nack" ref="a74511edfcada3fb21c3327a0c846c72a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave0Nack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 0 NACK status. This bit automatically sets to 1 when the 
I2C Master receives a NACK in a transaction with Slave 0. This triggers 
an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register 
(Register 56) is asserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Slave 0 NACK interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="afd6a9b55a589c83c9a0fb0b5b2a88234"></a><!-- doxytag: member="MPU6050::getSlave1FIFOEnabled" ref="afd6a9b55a589c83c9a0fb0b5b2a88234" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave1FIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 1 FIFO enabled value. When set to 1, this bit enables 
EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to 
be written into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Slave 1 FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a65cc9d75ff347b146414685fb83fa451"></a><!-- doxytag: member="MPU6050::getSlave1Nack" ref="a65cc9d75ff347b146414685fb83fa451" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave1Nack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 1 NACK status. This bit automatically sets to 1 when the 
I2C Master receives a NACK in a transaction with Slave 1. This triggers 
an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register 
(Register 56) is asserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Slave 1 NACK interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a3c2e29508607a655221a2fa4f4219b4d"></a><!-- doxytag: member="MPU6050::getSlave2FIFOEnabled" ref="a3c2e29508607a655221a2fa4f4219b4d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave2FIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 2 FIFO enabled value. When set to 1, this bit enables 
EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to 
be written into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Slave 2 FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="af4b5101dab501d6df2e0cae909120771"></a><!-- doxytag: member="MPU6050::getSlave2Nack" ref="af4b5101dab501d6df2e0cae909120771" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave2Nack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 2 NACK status. This bit automatically sets to 1 when the 
I2C Master receives a NACK in a transaction with Slave 2. This triggers 
an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register 
(Register 56) is asserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Slave 2 NACK interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a9d75ec63e2320ecfb84a2b082397f900"></a><!-- doxytag: member="MPU6050::getSlave3FIFOEnabled" ref="a9d75ec63e2320ecfb84a2b082397f900" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave3FIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 3 FIFO enabled value. When set to 1, this bit enables 
EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 3 to 
be written into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Slave 3 FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a55f24d2f2b13d6e28a7c8b6bf2913520"></a><!-- doxytag: member="MPU6050::getSlave3Nack" ref="a55f24d2f2b13d6e28a7c8b6bf2913520" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave3Nack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 3 NACK status. This bit automatically sets to 1 when the 
I2C Master receives a NACK in a transaction with Slave 3. This triggers 
an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register 
(Register 56) is asserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Slave 3 NACK interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a4278dec5fec25be9a6f45b51a3373ad2"></a><!-- doxytag: member="MPU6050::getSlave4Address" ref="a4278dec5fec25be9a6f45b51a3373ad2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlave4Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the I2C address of Slave 4. Note that Bit 7 (MSB) controls 
read/write mode. If Bit 7 is set, it's a read operation, and if it is 
cleared, then it's a write operation. The remaining bits (6-0) are the 
7-bit device address of the slave device.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current address for Slave 4 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af75b9f7ccac48515c7544238db0e6863">getSlaveAddress()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_ADDR </dd></dl>

</div>
</div>
<a class="anchor" id="a4b9e13d6776ba99e042773873557bedd"></a><!-- doxytag: member="MPU6050::getSlave4Enabled" ref="a4b9e13d6776ba99e042773873557bedd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave4Enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the enabled value for the Slave 4. When set to 1, this bit 
enables Slave 4 for data transfer operations. When cleared to 0, this 
bit disables Slave 4 from data transfer operations. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current enabled value for Slave 4 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a051549bcfa2eeb848c8557fc3efe74da"></a><!-- doxytag: member="MPU6050::getSlave4InterruptEnabled" ref="a051549bcfa2eeb848c8557fc3efe74da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave4InterruptEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the enabled value for Slave 4 transaction interrupts. When set to
 1, this bit enables the generation of an interrupt signal upon 
completion of a Slave 4 transaction. When cleared to 0, this bit 
disables the generation of an interrupt signal upon completion of a 
Slave 4 transaction. The interrupt status can be observed in Register 
54.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current enabled value for Slave 4 transaction interrupts. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a105aefe645e7021f9ba4397e9df4114c"></a><!-- doxytag: member="MPU6050::getSlave4IsDone" ref="a105aefe645e7021f9ba4397e9df4114c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave4IsDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 4 transaction done status. Automatically sets to 1 when a 
Slave 4 transaction has completed. This triggers an interrupt if the 
I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted 
and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register 
(Register 52). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Slave 4 transaction done status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a9a4585b3c9e61478db198011107a56a9"></a><!-- doxytag: member="MPU6050::getSlave4MasterDelay" ref="a9a4585b3c9e61478db198011107a56a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlave4MasterDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 4 master delay value. This configures the reduced access 
rate of I2C slaves relative to the Sample Rate. When a slave's access 
rate is decreased relative to the Sample Rate, the slave is accessed 
every:</p>
<p>1 / (1 + I2C_MST_DLY) samples</p>
<p>This base Sample Rate in turn is determined by SMPLRT_DIV (register 
25) and DLPF_CFG (register 26). Whether a slave's access rate is reduced
 relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL 
(register 103). For further information regarding the Sample Rate, 
please refer to register 25.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Slave 4 master delay value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="ae9882b425cbdced4de325b608d896e10"></a><!-- doxytag: member="MPU6050::getSlave4Nack" ref="ae9882b425cbdced4de325b608d896e10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave4Nack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Slave 4 NACK status. This bit automatically sets to 1 when the 
I2C Master receives a NACK in a transaction with Slave 4. This triggers 
an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register 
(Register 56) is asserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Slave 4 NACK interrupt status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd548cb60ecceb27c72f026ec0a60f8"></a><!-- doxytag: member="MPU6050::getSlave4Register" ref="a7bd548cb60ecceb27c72f026ec0a60f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlave4Register </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the active internal register for the Slave 4. Read/write 
operations for this slave will be done to whatever internal register 
address is stored in this MPU register.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current active register for Slave 4 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_REG </dd></dl>

</div>
</div>
<a class="anchor" id="a8d5a5e73907c78960154b92656127372"></a><!-- doxytag: member="MPU6050::getSlave4WriteMode" ref="a8d5a5e73907c78960154b92656127372" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlave4WriteMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get write mode for Slave 4. When set to 1, the transaction will read 
or write data only. When cleared to 0, the transaction will write a 
register address prior to reading or writing data. This should equal 0 
when specifying the register address within the Slave device to/from 
which the ensuing data transaction will take place.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current write mode for Slave 4 (0 = register address + data, 1 = data only) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="af75b9f7ccac48515c7544238db0e6863"></a><!-- doxytag: member="MPU6050::getSlaveAddress" ref="af75b9f7ccac48515c7544238db0e6863" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlaveAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the I2C address of the specified slave (0-3). Note that Bit 7 
(MSB) controls read/write mode. If Bit 7 is set, it's a read operation, 
and if it is cleared, then it's a write operation. The remaining bits 
(6-0) are the 7-bit device address of the slave device.</p>
<p>In read mode, the result of the read is placed in the lowest 
available EXT_SENS_DATA register. For further information regarding the 
allocation of read results, please refer to the EXT_SENS_DATA register 
description (Registers 73  96).</p>
<p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique 
characteristics, and so it has its own functions (getSlave4* and 
setSlave4*).</p>
<p>I2C data transactions are performed at the Sample Rate, as defined in
 Register 25. The user is responsible for ensuring that I2C data 
transactions to and from each enabled Slave can be completed within a 
single period of the Sample Rate.</p>
<p>The I2C slave access rate can be reduced relative to the Sample Rate.
 This reduced access rate is determined by I2C_MST_DLY (Register 52). 
Whether a slave's access rate is reduced relative to the Sample Rate is 
determined by I2C_MST_DELAY_CTRL (Register 103).</p>
<p>The processing order for the slaves is fixed. The sequence followed 
for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and 
Slave 4. If a particular Slave is disabled it will be skipped.</p>
<p>Each slave can either be accessed at the sample rate or at a reduced 
sample rate. In a case where some slaves are accessed at the Sample Rate
 and some slaves are accessed at the reduced rate, the sequence of 
accessing the slaves (Slave 0 to Slave 4) is still followed. However, 
the reduced rate slaves will be skipped if their access rate dictates 
that they should not be accessed during that particular cycle. For 
further information regarding the reduced access rate, please refer to 
Register 52. Whether a slave is accessed at the Sample Rate or at the 
reduced rate is determined by the Delay Enable bits in Register 103.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current address for specified slave </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_ADDR </dd></dl>

</div>
</div>
<a class="anchor" id="a54c2a48b3cb79106bcaf75accf6cd311"></a><!-- doxytag: member="MPU6050::getSlaveDataLength" ref="a54c2a48b3cb79106bcaf75accf6cd311" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlaveDataLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get number of bytes to read for the specified slave (0-3). Specifies 
the number of bytes transferred to and from Slave 0. Clearing this bit 
to 0 is equivalent to disabling the register by writing 0 to 
I2C_SLV0_EN. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes to read for specified slave </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="ae84fd795630f9ab5e8d6b19a616a11ce"></a><!-- doxytag: member="MPU6050::getSlaveDelayEnabled" ref="ae84fd795630f9ab5e8d6b19a616a11ce" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlaveDelayEnabled </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get slave delay enabled status. When a particular slave delay is 
enabled, the rate of access for the that slave device is reduced. When a
 slave's access rate is decreased relative to the Sample Rate, the slave
 is accessed every:</p>
<p>1 / (1 + I2C_MST_DLY) Samples</p>
<p>This base Sample Rate in turn is determined by SMPLRT_DIV (register * 25) and DLPF_CFG (register 26).</p>
<p>For further information regarding I2C_MST_DLY, please refer to 
register 52. For further information regarding the Sample Rate, please 
refer to register 25.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-4) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current slave delay enabled status. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_DELAY_CTRL </dd>
<dd>
MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a5f14bde83fe00b27dec6776fc44e89c2"></a><!-- doxytag: member="MPU6050::getSlaveEnabled" ref="a5f14bde83fe00b27dec6776fc44e89c2" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlaveEnabled </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the enabled value for the specified slave (0-3). When set to 1, 
this bit enables Slave 0 for data transfer operations. When cleared to 
0, this bit disables Slave 0 from data transfer operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current enabled value for specified slave </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a6b3c3aab80fcaa384303f9df2a59d7eb"></a><!-- doxytag: member="MPU6050::getSlaveReadWriteTransitionEnabled" ref="a6b3c3aab80fcaa384303f9df2a59d7eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlaveReadWriteTransitionEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get slave read/write transition enabled value. The I2C_MST_P_NSR bit 
configures the I2C Master's transition from one slave read to the next 
slave read. If the bit equals 0, there will be a restart between reads. 
If the bit equals 1, there will be a stop followed by a start of the 
following read. When a write transaction follows a read transaction, the
 stop followed by a start of the successive write will be always used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current slave read/write transition enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="ae7e9ead9645bcef326eb579c6ab5d5ff"></a><!-- doxytag: member="MPU6050::getSlaveRegister" ref="ae7e9ead9645bcef326eb579c6ab5d5ff" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getSlaveRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get the active internal register for the specified slave (0-3). 
Read/write operations for this slave will be done to whatever internal 
register address is stored in this MPU register.</p>
<p>The MPU-6050 supports a total of five slaves, but Slave 4 has unique characteristics, and so it has its own functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current active register for specified slave </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_REG </dd></dl>

</div>
</div>
<a class="anchor" id="a18e8f3d053a68f0e5ecf497c87ecac8a"></a><!-- doxytag: member="MPU6050::getSlaveWordByteSwap" ref="a18e8f3d053a68f0e5ecf497c87ecac8a" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlaveWordByteSwap </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get word pair byte-swapping enabled for the specified slave (0-3). 
When set to 1, this bit enables byte swapping. When byte swapping is 
enabled, the high and low bytes of a word pair are swapped. Please refer
 to I2C_SLV0_GRP for the pairing convention of the word pairs. When 
cleared to 0, bytes transferred to and from Slave 0 will be written to 
EXT_SENS_DATA registers in the order they were transferred.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current word pair byte-swapping enabled value for specified slave </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a32ce8023bb80afc5d55811de70c7214f"></a><!-- doxytag: member="MPU6050::getSlaveWordGroupOffset" ref="a32ce8023bb80afc5d55811de70c7214f" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlaveWordGroupOffset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get word pair grouping order offset for the specified slave (0-3). 
This sets specifies the grouping order of word pairs received from 
registers. When cleared to 0, bytes from register addresses 0 and 1, 2 
and 3, etc (even, then odd register addresses) are paired to form a 
word. When set to 1, bytes from register addresses are paired 1 and 2, 3
 and 4, etc. (odd, then even register addresses) are paired to form a 
word.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current word pair grouping order offset for specified slave </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="adb99955fa66300b1f0bedfcdd8187412"></a><!-- doxytag: member="MPU6050::getSlaveWriteMode" ref="adb99955fa66300b1f0bedfcdd8187412" args="(uint8_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSlaveWriteMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get write mode for the specified slave (0-3). When set to 1, the 
transaction will read or write data only. When cleared to 0, the 
transaction will write a register address prior to reading or writing 
data. This should equal 0 when specifying the register address within 
the Slave device to/from which the ensuing data transaction will take 
place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current write mode for specified slave (0 = register address + data, 1 = data only) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a196404ef04b959083d4bf5e6f1cd8b98"></a><!-- doxytag: member="MPU6050::getSleepEnabled" ref="a196404ef04b959083d4bf5e6f1cd8b98" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getSleepEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get sleep mode status. Setting the SLEEP bit in the register puts the
 device into very low power sleep mode. In this mode, only the serial 
interface and internal registers remain active, allowing for a very low 
standby current. Clearing this bit puts the device back into normal 
mode. To save power, the individual standby selections for each of the 
gyros should be used if any gyro axis is not used by the application. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current sleep mode enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_SLEEP_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a99261a04739fdb7a9a1c5b67ce3e710e"></a><!-- doxytag: member="MPU6050::getStandbyXAccelEnabled" ref="a99261a04739fdb7a9a1c5b67ce3e710e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getStandbyXAccelEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get X-axis accelerometer standby enabled status. If enabled, the X-axis will not gather or report data (or use power). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current X-axis standby enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_XA_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="acb5fde4167aa54fbbe84706d577a48a6"></a><!-- doxytag: member="MPU6050::getStandbyXGyroEnabled" ref="acb5fde4167aa54fbbe84706d577a48a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getStandbyXGyroEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get X-axis gyroscope standby enabled status. If enabled, the X-axis will not gather or report data (or use power). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current X-axis standby enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_XG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a104f2ec438d745f8fdeec202bae09b48"></a><!-- doxytag: member="MPU6050::getStandbyYAccelEnabled" ref="a104f2ec438d745f8fdeec202bae09b48" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getStandbyYAccelEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Y-axis accelerometer standby enabled status. If enabled, the Y-axis will not gather or report data (or use power). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Y-axis standby enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_YA_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="aaad2985f8d22aec123f1e1dabcdd427a"></a><!-- doxytag: member="MPU6050::getStandbyYGyroEnabled" ref="aaad2985f8d22aec123f1e1dabcdd427a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getStandbyYGyroEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Y-axis gyroscope standby enabled status. If enabled, the Y-axis will not gather or report data (or use power). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Y-axis standby enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_YG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="adae85612e047c4c7f0c3b7110fc92956"></a><!-- doxytag: member="MPU6050::getStandbyZAccelEnabled" ref="adae85612e047c4c7f0c3b7110fc92956" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getStandbyZAccelEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Z-axis accelerometer standby enabled status. If enabled, the Z-axis will not gather or report data (or use power). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Z-axis standby enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_ZA_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a20f7804db1a980a3c425ae44c33d420b"></a><!-- doxytag: member="MPU6050::getStandbyZGyroEnabled" ref="a20f7804db1a980a3c425ae44c33d420b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getStandbyZGyroEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Z-axis gyroscope standby enabled status. If enabled, the Z-axis will not gather or report data (or use power). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current Z-axis standby enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_ZG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="aedfa4f1e6507f48c0a09545345a87875"></a><!-- doxytag: member="MPU6050::getTemperature" ref="aedfa4f1e6507f48c0a09545345a87875" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">int16_t MPU6050::getTemperature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get current internal temperature. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Temperature reading in 16-bit 2's complement format </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_TEMP_OUT_H </dd></dl>

</div>
</div>
<a class="anchor" id="a913c2095001e204b5b09f8382a86d2ca"></a><!-- doxytag: member="MPU6050::getTempFIFOEnabled" ref="a913c2095001e204b5b09f8382a86d2ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getTempFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get temperature FIFO enabled value. When set to 1, this bit enables 
TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the 
FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current temperature FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a31f588beab6760258212c65725eba336"></a><!-- doxytag: member="MPU6050::getTempSensorEnabled" ref="a31f588beab6760258212c65725eba336" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getTempSensorEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get temperature sensor enabled status. Control the usage of the internal temperature sensor.</p>
<p>Note: this register stores the *disabled* value, but for consistency 
with the rest of the code, the function is named and used with standard 
true/false values to indicate whether the sensor is enabled or disabled,
 respectively.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current temperature sensor enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_TEMP_DIS_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a4e2ebda47b85b4c5463f041c790bf5c0"></a><!-- doxytag: member="MPU6050::getWaitForExternalSensorEnabled" ref="a4e2ebda47b85b4c5463f041c790bf5c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getWaitForExternalSensorEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get wait-for-external-sensor-data enabled value. When the WAIT_FOR_ES
 bit is set to 1, the Data Ready interrupt will be delayed until 
External Sensor data from the Slave Devices are loaded into the 
EXT_SENS_DATA registers. This is used to ensure that both the internal 
sensor data (i.e. from gyro and accel) and external sensor data have 
been loaded to their respective data registers (i.e. the data is synced)
 when the Data Ready interrupt is triggered.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current wait-for-external-sensor-data enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a89afc5235b9088c696e2cc7841f5259a"></a><!-- doxytag: member="MPU6050::getWakeCycleEnabled" ref="a89afc5235b9088c696e2cc7841f5259a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getWakeCycleEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get wake cycle enabled status. When this bit is set to 1 and SLEEP is
 disabled, the MPU-60X0 will cycle between sleep mode and waking up to 
take a single sample of data from active sensors at a rate determined by
 LP_WAKE_CTRL (register 108). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current sleep mode enabled status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_CYCLE_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a249a905ae4572a462414f2d94236258a"></a><!-- doxytag: member="MPU6050::getWakeFrequency" ref="a249a905ae4572a462414f2d94236258a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getWakeFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get wake frequency in Accel-Only Low Power Mode. The MPU-60X0 can be 
put into Accerlerometer Only Low Power Mode by setting PWRSEL to 1 in 
the Power Management 1 register (Register 107). In this mode, the device
 will power off all devices except for the primary I2C interface, waking
 only the accelerometer at fixed intervals to take a single measurement.
 The frequency of wake-ups can be configured with LP_WAKE_CTRL as shown 
below:</p>
<pre> LP_WAKE_CTRL | Wake-up Frequency
 -------------+------------------
 0            | 1.25 Hz
 1            | 2.5 Hz
 2            | 5 Hz
 3            | 10 Hz
 <p></p>
<pre></pre></pre><pre><pre> For further information regarding the MPU-60X0's power modes, please refer to
 Register 107.</pre></pre><pre><pre> <dl class="return"><dt><b>Returns:</b></dt><dd>Current wake frequency
 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2
</dd></dl>
</pre></pre>
</div>
</div>
<a class="anchor" id="ada9a553176b57815f23fb7d71bb85c9d"></a><!-- doxytag: member="MPU6050::getXGyroFIFOEnabled" ref="ada9a553176b57815f23fb7d71bb85c9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getXGyroFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get gyroscope X-axis FIFO enabled value. When set to 1, this bit 
enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written 
into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current gyroscope X-axis FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a446d235905783c5b90637a6b6792ac76"></a><!-- doxytag: member="MPU6050::getXNegMotionDetected" ref="a446d235905783c5b90637a6b6792ac76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getXNegMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get X-axis negative motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_XNEG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a410af58f5ff5f74e4ef8d61495908226"></a><!-- doxytag: member="MPU6050::getXPosMotionDetected" ref="a410af58f5ff5f74e4ef8d61495908226" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getXPosMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get X-axis positive motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_XPOS_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a86c85d5b5c93df82394435b868e17463"></a><!-- doxytag: member="MPU6050::getYGyroFIFOEnabled" ref="a86c85d5b5c93df82394435b868e17463" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getYGyroFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get gyroscope Y-axis FIFO enabled value. When set to 1, this bit 
enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written 
into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current gyroscope Y-axis FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a6c45be7b4aa9081c83ee0f4081bf0827"></a><!-- doxytag: member="MPU6050::getYNegMotionDetected" ref="a6c45be7b4aa9081c83ee0f4081bf0827" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getYNegMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Y-axis negative motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_YNEG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ad959ec84b9fe9f7e416b7af252f37abc"></a><!-- doxytag: member="MPU6050::getYPosMotionDetected" ref="ad959ec84b9fe9f7e416b7af252f37abc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getYPosMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Y-axis positive motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_YPOS_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a384765351b5c4bd2b6efec9ed71ad1b7"></a><!-- doxytag: member="MPU6050::getZeroMotionDetected" ref="a384765351b5c4bd2b6efec9ed71ad1b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getZeroMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get zero motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_ZRMOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a04c0fcdcd0157b6dbf74d4901424801e"></a><!-- doxytag: member="MPU6050::getZeroMotionDetectionDuration" ref="a04c0fcdcd0157b6dbf74d4901424801e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getZeroMotionDetectionDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get zero motion detection event duration threshold. This register 
configures the duration counter threshold for Zero Motion interrupt 
generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has
 a unit of 1 LSB = 64 ms. The Zero Motion duration counter increments 
while the absolute value of the accelerometer measurements are each less
 than the detection threshold (Register 33). The Zero Motion interrupt 
is triggered when the Zero Motion duration counter reaches the time 
count specified in this register.</p>
<p>For more details on the Zero Motion detection interrupt, see Section 
8.4 of the MPU-6000/MPU-6050 Product Specification document, as well as 
Registers 56 and 58 of this document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current zero motion detection duration threshold value (LSB = 64ms) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ZRMOT_DUR </dd></dl>

</div>
</div>
<a class="anchor" id="ad941c1e844dc9230675c115734599ea3"></a><!-- doxytag: member="MPU6050::getZeroMotionDetectionThreshold" ref="ad941c1e844dc9230675c115734599ea3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">uint8_t MPU6050::getZeroMotionDetectionThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get zero motion detection event acceleration threshold. This register
 configures the detection threshold for Zero Motion interrupt 
generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected
 when the absolute value of the accelerometer measurements for the 3 
axes are each less than the detection threshold. This condition 
increments the Zero Motion duration counter (Register 34). The Zero 
Motion interrupt is triggered when the Zero Motion duration counter 
reaches the time count specified in ZRMOT_DUR (Register 34).</p>
<p>Unlike Free Fall or Motion detection, Zero Motion detection triggers 
an interrupt both when Zero Motion is first detected and when Zero 
Motion is no longer detected.</p>
<p>When a zero motion event is detected, a Zero Motion Status will be 
indicated in the MOT_DETECT_STATUS register (Register 97). When a 
motion-to-zero-motion condition is detected, the status bit is set to 1.
 When a zero-motion-to- motion condition is detected, the status bit is 
set to 0.</p>
<p>For more details on the Zero Motion detection interrupt, see Section 
8.4 of the MPU-6000/MPU-6050 Product Specification document as well as 
Registers 56 and 58 of this document.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current zero motion detection acceleration threshold value (LSB = 2mg) </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ZRMOT_THR </dd></dl>

</div>
</div>
<a class="anchor" id="adbbbd131c74f37dd545403633eb317ff"></a><!-- doxytag: member="MPU6050::getZGyroFIFOEnabled" ref="adbbbd131c74f37dd545403633eb317ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getZGyroFIFOEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get gyroscope Z-axis FIFO enabled value. When set to 1, this bit 
enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written 
into the FIFO buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current gyroscope Z-axis FIFO enabled value </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a3601b732eb15644212b8f29cf396e142"></a><!-- doxytag: member="MPU6050::getZNegMotionDetected" ref="a3601b732eb15644212b8f29cf396e142" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getZNegMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Z-axis negative motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_ZNEG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a33c766cd415fc5780417b1ed76717875"></a><!-- doxytag: member="MPU6050::getZPosMotionDetected" ref="a33c766cd415fc5780417b1ed76717875" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::getZPosMotionDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get Z-axis positive motion detection interrupt status. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Motion detection status </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_MOT_DETECT_STATUS </dd>
<dd>
MPU6050_MOTION_MOT_ZPOS_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="abd8fc6c18adf158011118fbccc7e7054"></a><!-- doxytag: member="MPU6050::initialize" ref="abd8fc6c18adf158011118fbccc7e7054" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Power on and prepare for general usage. This will activate the device
 and take it out of sleep mode (which must be done after start-up). This
 function also sets both the accelerometer and the gyroscope to their 
most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets
 the clock source to use the X Gyro for reference, which is slightly 
better than the default internal clock source. </p>

</div>
</div>
<a class="anchor" id="a7100b6d276c3c8664cf00d768b7b0dee"></a><!-- doxytag: member="MPU6050::reset" ref="a7100b6d276c3c8664cf00d768b7b0dee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Trigger a full device reset. A small delay of ~50ms may be desirable after triggering a reset. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_DEVICE_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a99ee74708c12f32e48ef5ec69ac9f4a9"></a><!-- doxytag: member="MPU6050::resetAccelerometerPath" ref="a99ee74708c12f32e48ef5ec69ac9f4a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::resetAccelerometerPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Reset accelerometer signal path. The reset will revert the signal 
path analog to digital converters and filters to their power up 
configurations. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_SIGNAL_PATH_RESET </dd>
<dd>
MPU6050_PATHRESET_ACCEL_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="aafa0dc38b7ea2acd1aecd5d9df8cbd08"></a><!-- doxytag: member="MPU6050::resetFIFO" ref="aafa0dc38b7ea2acd1aecd5d9df8cbd08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::resetFIFO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Reset the FIFO. This bit resets the FIFO buffer when set to 1 while 
FIFO_EN equals 0. This bit automatically clears to 0 after the reset has
 been triggered. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_FIFO_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="af1599c0d70f07fd3e28683d571842c22"></a><!-- doxytag: member="MPU6050::resetGyroscopePath" ref="af1599c0d70f07fd3e28683d571842c22" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::resetGyroscopePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Reset gyroscope signal path. The reset will revert the signal path 
analog to digital converters and filters to their power up 
configurations. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_SIGNAL_PATH_RESET </dd>
<dd>
MPU6050_PATHRESET_GYRO_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a96332c394f1b7efd44c83a4ff690e732"></a><!-- doxytag: member="MPU6050::resetI2CMaster" ref="a96332c394f1b7efd44c83a4ff690e732" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::resetI2CMaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Reset the I2C Master. This bit resets the I2C Master when set to 1 
while I2C_MST_EN equals 0. This bit automatically clears to 0 after the 
reset has been triggered. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_I2C_MST_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a9a271104d3302abc4af005c69a930094"></a><!-- doxytag: member="MPU6050::resetSensors" ref="a9a271104d3302abc4af005c69a930094" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::resetSensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Reset all sensor registers and signal paths. When set to 1, this bit 
resets the signal paths for all sensors (gyroscopes, accelerometers, and
 temperature sensor). This operation will also clear the sensor 
registers. This bit automatically clears to 0 after the reset has been 
triggered.</p>
<p>When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_SIG_COND_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a559c2d091d36a4e0489bc639916ddbb6"></a><!-- doxytag: member="MPU6050::resetTemperaturePath" ref="a559c2d091d36a4e0489bc639916ddbb6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::resetTemperaturePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Reset temperature sensor signal path. The reset will revert the 
signal path analog to digital converters and filters to their power up 
configurations. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_SIGNAL_PATH_RESET </dd>
<dd>
MPU6050_PATHRESET_TEMP_RESET_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbde7653d2d2d37e16e515599f3b08b"></a><!-- doxytag: member="MPU6050::setAccelerometerPowerOnDelay" ref="a2bbde7653d2d2d37e16e515599f3b08b" args="(uint8_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setAccelerometerPowerOnDelay </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set accelerometer power-on delay. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">delay</td><td>New accelerometer power-on delay (0-3) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aae903df2accc687423f9cd0a78f9cd32">getAccelerometerPowerOnDelay()</a> </dd>
<dd>
MPU6050_RA_MOT_DETECT_CTRL </dd>
<dd>
MPU6050_DETECT_ACCEL_ON_DELAY_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="afccbee85f5cdc95098f6d62d8d417c3f"></a><!-- doxytag: member="MPU6050::setAccelFIFOEnabled" ref="afccbee85f5cdc95098f6d62d8d417c3f" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setAccelFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set accelerometer FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New accelerometer FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ace244415128ad7a38293ad6808b7face">getAccelFIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="ac2ab843dc9d241056ed0f891195cdbf9"></a><!-- doxytag: member="MPU6050::setAccelXSelfTest" ref="ac2ab843dc9d241056ed0f891195cdbf9" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setAccelXSelfTest </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get self-test enabled setting for accelerometer X axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>Self-test enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="ad5847430ab297959e4d0e9b81ba2e3ba"></a><!-- doxytag: member="MPU6050::setAccelYSelfTest" ref="ad5847430ab297959e4d0e9b81ba2e3ba" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setAccelYSelfTest </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get self-test enabled value for accelerometer Y axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>Self-test enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="a8eb8ba039af9a47e0475a3835b87f404"></a><!-- doxytag: member="MPU6050::setAccelZSelfTest" ref="a8eb8ba039af9a47e0475a3835b87f404" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setAccelZSelfTest </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set self-test enabled value for accelerometer Z axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>Self-test enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="a7c666c20e26869bc80646f1b2c3d69bc"></a><!-- doxytag: member="MPU6050::setAuxVDDIOLevel" ref="a7c666c20e26869bc80646f1b2c3d69bc" args="(uint8_t level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setAuxVDDIOLevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the auxiliary I2C supply voltage level. When set to 1, the 
auxiliary I2C bus high logic level is VDD. When cleared to 0, the 
auxiliary I2C bus high logic level is VLOGIC. This does not apply to the
 MPU-6000, which does not have a VLOGIC pin. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">level</td><td>I2C supply voltage level (0=VLOGIC, 1=VDD) </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71ec4642b6f6c937bbf6a24fea4179e5"></a><!-- doxytag: member="MPU6050::setClockOutputEnabled" ref="a71ec4642b6f6c937bbf6a24fea4179e5" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setClockOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set reference clock output enabled status. When this bit is equal to 
1, a reference clock output is provided at the CLKOUT pin. When this bit
 is equal to 0, the clock output is disabled. For further information 
regarding CLKOUT, please refer to the MPU-60X0 Product Specification 
document. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New reference clock output enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_CLKOUT_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a4c1cd147d038e024bdeaa053c4d77734"></a><!-- doxytag: member="MPU6050::setClockSource" ref="a4c1cd147d038e024bdeaa053c4d77734" args="(uint8_t source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setClockSource </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set clock source setting. An internal 8MHz oscillator, gyroscope 
based clock, or external sources can be selected as the MPU-60X0 clock 
source. When the internal 8 MHz oscillator or an external source is 
chosen as the clock source, the MPU-60X0 can operate in low power modes 
with the gyroscopes disabled.</p>
<p>Upon power up, the MPU-60X0 clock source defaults to the internal 
oscillator. However, it is highly recommended that the device be 
configured to use one of the gyroscopes (or an external clock source) as
 the clock reference for improved stability. The clock source can be 
selected according to the following table:</p>
<pre> CLK_SEL | Clock Source
 --------+--------------------------------------
 0       | Internal oscillator
 1       | PLL with X Gyro reference
 2       | PLL with Y Gyro reference
 3       | PLL with Z Gyro reference
 4       | PLL with external 32.768kHz reference
 5       | PLL with external 19.2MHz reference
 6       | Reserved
 7       | Stops the clock and keeps the timing generator in reset
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">source</td><td>New clock source setting </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ed670258a805807b5102cdc5d0996a8">getClockSource()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_CLKSEL_BIT </dd>
<dd>
MPU6050_PWR1_CLKSEL_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="aaefb4b3d93cf4b78d56cd63b10ea0e97"></a><!-- doxytag: member="MPU6050::setDeviceID" ref="aaefb4b3d93cf4b78d56cd63b10ea0e97" args="(uint8_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setDeviceID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Device ID. Write a new ID into the WHO_AM_I register (no idea why this should ever be necessary though). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">id</td><td>New device ID to set. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a35ae3c8894b3258e642043886801e031">getDeviceID()</a> </dd>
<dd>
MPU6050_RA_WHO_AM_I </dd>
<dd>
MPU6050_WHO_AM_I_BIT </dd>
<dd>
MPU6050_WHO_AM_I_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="a44cc43aaad1e52c1ba3142d4490af611"></a><!-- doxytag: member="MPU6050::setDHPFMode" ref="a44cc43aaad1e52c1ba3142d4490af611" args="(uint8_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setDHPFMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>bandwidth</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the high-pass filter configuration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">bandwidth</td><td>New high-pass filter configuration </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a44cc43aaad1e52c1ba3142d4490af611">setDHPFMode()</a> </dd>
<dd>
MPU6050_DHPF_RESET </dd>
<dd>
MPU6050_RA_ACCEL_CONFIG </dd></dl>

</div>
</div>
<a class="anchor" id="a7a782ade8af2f88dfef7171487f59a3b"></a><!-- doxytag: member="MPU6050::setDLPFMode" ref="a7a782ade8af2f88dfef7171487f59a3b" args="(uint8_t bandwidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setDLPFMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set digital low-pass filter configuration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mode</td><td>New DLFP configuration setting </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getDLPFBandwidth() </dd>
<dd>
MPU6050_DLPF_BW_256 </dd>
<dd>
MPU6050_RA_CONFIG </dd>
<dd>
MPU6050_CFG_DLPF_CFG_BIT </dd>
<dd>
MPU6050_CFG_DLPF_CFG_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="a77b36f41c531a11b5a835fc75a9aefe6"></a><!-- doxytag: member="MPU6050::setExternalFrameSync" ref="a77b36f41c531a11b5a835fc75a9aefe6" args="(uint8_t sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setExternalFrameSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set external FSYNC configuration. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a902a7d486cd6ac21f8c378634dc6f59a">getExternalFrameSync()</a> </dd>
<dd>
MPU6050_RA_CONFIG </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">sync</td><td>New FSYNC configuration value </td></tr>
  </tbody></table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9160193d883871037c6535a9d3e02ee2"></a><!-- doxytag: member="MPU6050::setExternalShadowDelayEnabled" ref="a9160193d883871037c6535a9d3e02ee2" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setExternalShadowDelayEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set external data shadow delay enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New external data shadow delay enabled status. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0e5cb13838298609b5260fd1558f8c92">getExternalShadowDelayEnabled()</a> </dd>
<dd>
MPU6050_RA_I2C_MST_DELAY_CTRL </dd>
<dd>
MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a66da5bc38aa82404117d1ef5306c951a"></a><!-- doxytag: member="MPU6050::setFIFOByte" ref="a66da5bc38aa82404117d1ef5306c951a" args="(uint8_t data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFIFOByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Write byte to FIFO buffer. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7733011d30d5b64564f6b5422d8639ae">getFIFOByte()</a> </dd>
<dd>
MPU6050_RA_FIFO_R_W </dd></dl>

</div>
</div>
<a class="anchor" id="a78e58ab27986db6999af775ed4d43091"></a><!-- doxytag: member="MPU6050::setFIFOEnabled" ref="a78e58ab27986db6999af775ed4d43091" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set FIFO enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New FIFO enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae2687a09ebe0d7fbbf74f560e0dd9a44">getFIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_FIFO_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a18dd79b7c53600e9ce97eed4bfe6cf15"></a><!-- doxytag: member="MPU6050::setFreefallDetectionCounterDecrement" ref="a18dd79b7c53600e9ce97eed4bfe6cf15" args="(uint8_t decrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFreefallDetectionCounterDecrement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>decrement</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Free Fall detection counter decrement configuration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">decrement</td><td>New decrement configuration value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af6d6fa9869636989a8b29c4827ad7de8">getFreefallDetectionCounterDecrement()</a> </dd>
<dd>
MPU6050_RA_MOT_DETECT_CTRL </dd>
<dd>
MPU6050_DETECT_FF_COUNT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a41eeb40a654465966d260e3d31c4de4b"></a><!-- doxytag: member="MPU6050::setFreefallDetectionDuration" ref="a41eeb40a654465966d260e3d31c4de4b" args="(uint8_t duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFreefallDetectionDuration </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get free-fall event duration threshold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">duration</td><td>New free-fall duration threshold value (LSB = 1ms) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3cff6b9613ad01aa1a51c287f5c5e329">getFreefallDetectionDuration()</a> </dd>
<dd>
MPU6050_RA_FF_DUR </dd></dl>

</div>
</div>
<a class="anchor" id="af704e1a4eb01522b146abeba78c32716"></a><!-- doxytag: member="MPU6050::setFreefallDetectionThreshold" ref="af704e1a4eb01522b146abeba78c32716" args="(uint8_t threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFreefallDetectionThreshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Get free-fall event acceleration threshold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">threshold</td><td>New free-fall acceleration threshold value (LSB = 2mg) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ac7f5c0511fe9d0f3525a3757498daed7">getFreefallDetectionThreshold()</a> </dd>
<dd>
MPU6050_RA_FF_THR </dd></dl>

</div>
</div>
<a class="anchor" id="a96aa409e02cdb7d3671890c70b44f167"></a><!-- doxytag: member="MPU6050::setFSyncInterruptEnabled" ref="a96aa409e02cdb7d3671890c70b44f167" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFSyncInterruptEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set FSYNC pin interrupt enabled setting. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New FSYNC pin interrupt enabled setting </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4c01f9ab83b64dbbc6b62e658c3d3d9b">getFSyncInterruptEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_FSYNC_INT_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a2b1c75cfc29e8ff8205f4ff33a426716"></a><!-- doxytag: member="MPU6050::setFSyncInterruptLevel" ref="a2b1c75cfc29e8ff8205f4ff33a426716" args="(bool level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFSyncInterruptLevel </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set FSYNC interrupt logic level mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mode</td><td>New FSYNC interrupt mode (0=active-high, 1=active-low) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getFSyncInterruptMode() </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a64eb78e8e359c541beaf8664db3421d1"></a><!-- doxytag: member="MPU6050::setFullScaleAccelRange" ref="a64eb78e8e359c541beaf8664db3421d1" args="(uint8_t range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFullScaleAccelRange </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set full-scale accelerometer range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">range</td><td>New full-scale accelerometer range setting </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0fe2dad60c170cee7d614e08f243ffd0">getFullScaleAccelRange()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a72afc0b6f221c9336f635b5637c62dae"></a><!-- doxytag: member="MPU6050::setFullScaleGyroRange" ref="a72afc0b6f221c9336f635b5637c62dae" args="(uint8_t range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setFullScaleGyroRange </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set full-scale gyroscope range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">range</td><td>New full-scale gyroscope range value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getFullScaleRange() </dd>
<dd>
MPU6050_GYRO_FS_250 </dd>
<dd>
MPU6050_RA_GYRO_CONFIG </dd>
<dd>
MPU6050_GCONFIG_FS_SEL_BIT </dd>
<dd>
MPU6050_GCONFIG_FS_SEL_LENGTH </dd></dl>

</div>
</div>
<a class="anchor" id="aa828160756a50f414aa3f5f5f0353c70"></a><!-- doxytag: member="MPU6050::setI2CBypassEnabled" ref="aa828160756a50f414aa3f5f5f0353c70" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setI2CBypassEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set I2C bypass enabled status. When this bit is equal to 1 and 
I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application 
processor will be able to directly access the auxiliary I2C bus of the 
MPU-60X0. When this bit is equal to 0, the host application processor 
will not be able to directly access the auxiliary I2C bus of the 
MPU-60X0 regardless of the state of I2C_MST_EN (Register 106 bit[5]). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New I2C bypass enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_I2C_BYPASS_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a6503f0fdfefa0fd287a75032667b7b69"></a><!-- doxytag: member="MPU6050::setI2CMasterModeEnabled" ref="a6503f0fdfefa0fd287a75032667b7b69" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setI2CMasterModeEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set I2C Master Mode enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New I2C Master Mode enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6b45e538f2082eb1b1975ed56e3e21bc">getI2CMasterModeEnabled()</a> </dd>
<dd>
MPU6050_RA_USER_CTRL </dd>
<dd>
MPU6050_USERCTRL_I2C_MST_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a67a11be7fc7ab6b1186469b94ea33dda"></a><!-- doxytag: member="MPU6050::setIntDataReadyEnabled" ref="a67a11be7fc7ab6b1186469b94ea33dda" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setIntDataReadyEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Data Ready interrupt enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New interrupt enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae15f6043a74c9c9bf9754824802ce8d3">getIntDataReadyEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_CFG </dd>
<dd>
MPU6050_INTERRUPT_DATA_RDY_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9d6aeea346e6f6fad8e4a428cf3301"></a><!-- doxytag: member="MPU6050::setInterruptDrive" ref="a9d9d6aeea346e6f6fad8e4a428cf3301" args="(bool drive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setInterruptDrive </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>drive</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set interrupt drive mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">drive</td><td>New interrupt drive mode (0=push-pull, 1=open-drain) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af66e6c7b1885dcf452e73371790fddfd">getInterruptDrive()</a> </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_INT_OPEN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="abf9ccf9eb6c7156e6660abb76734920a"></a><!-- doxytag: member="MPU6050::setInterruptLatch" ref="abf9ccf9eb6c7156e6660abb76734920a" args="(bool latch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setInterruptLatch </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set interrupt latch mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">latch</td><td>New latch mode (0=50us-pulse, 1=latch-until-int-cleared) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a5502c4c2a9bc4ea9267e128b7743923d">getInterruptLatch()</a> </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_LATCH_INT_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa64c7030242aac18bd6727e8ca4a54"></a><!-- doxytag: member="MPU6050::setInterruptLatchClear" ref="a2fa64c7030242aac18bd6727e8ca4a54" args="(bool clear)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setInterruptLatchClear </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>clear</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set interrupt latch clear mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">clear</td><td>New latch clear mode (0=status-read-only, 1=any-register-read) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9a098a607e20c64b60e155da35b8264f">getInterruptLatchClear()</a> </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_INT_RD_CLEAR_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a003a098a1521c5ef4df50c0a8a2d47ab"></a><!-- doxytag: member="MPU6050::setInterruptMode" ref="a003a098a1521c5ef4df50c0a8a2d47ab" args="(bool mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setInterruptMode </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set interrupt logic level mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mode</td><td>New interrupt mode (0=active-high, 1=active-low) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a58da1dfb39eb34e3a09a9b0bf4d87f29">getInterruptMode()</a> </dd>
<dd>
MPU6050_RA_INT_PIN_CFG </dd>
<dd>
MPU6050_INTCFG_INT_LEVEL_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a83710a6b1e07f3b385239cc06f275cdb"></a><!-- doxytag: member="MPU6050::setIntFIFOBufferOverflowEnabled" ref="a83710a6b1e07f3b385239cc06f275cdb" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setIntFIFOBufferOverflowEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set FIFO Buffer Overflow interrupt enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New interrupt enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a55f99c88cc84901f245924ed5e3fe47e">getIntFIFOBufferOverflowEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_FIFO_OFLOW_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a01a24a05f06463d5277e1670d6260e03"></a><!-- doxytag: member="MPU6050::setIntFreefallEnabled" ref="a01a24a05f06463d5277e1670d6260e03" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setIntFreefallEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Free Fall interrupt enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New interrupt enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a500bb2df2e46eaecd3fb2ba7304a5ed3">getIntFreefallEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_FF_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="af238656844a3727fa96a8d434b55473e"></a><!-- doxytag: member="MPU6050::setIntI2CMasterEnabled" ref="af238656844a3727fa96a8d434b55473e" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setIntI2CMasterEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set I2C Master interrupt enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New interrupt enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a282ae29e029d88604a59c92bdf9ce252">getIntI2CMasterEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_I2C_MST_INT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a2d2d1d3b03198a09c83a48ec3bc20bd8"></a><!-- doxytag: member="MPU6050::setIntMotionEnabled" ref="a2d2d1d3b03198a09c83a48ec3bc20bd8" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setIntMotionEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Motion Detection interrupt enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New interrupt enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7de31a8e9f22765329d9f9e02db2f1f0">getIntMotionEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_MOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a5e36e3acace6e545718d7997169cff9b"></a><!-- doxytag: member="MPU6050::setIntZeroMotionEnabled" ref="a5e36e3acace6e545718d7997169cff9b" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setIntZeroMotionEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Zero Motion Detection interrupt enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New interrupt enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ab3cc9bcaca6cec61e7f3f0c6c8a37db5">getIntZeroMotionEnabled()</a> </dd>
<dd>
MPU6050_RA_INT_ENABLE </dd>
<dd>
MPU6050_INTERRUPT_ZMOT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a8a4779ea709ff0633f9798369478400b"></a><!-- doxytag: member="MPU6050::setMasterClockSpeed" ref="a8a4779ea709ff0633f9798369478400b" args="(uint8_t speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setMasterClockSpeed </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set I2C master clock speed.  speed Current I2C master clock speed </p>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a74cc3ea727afa5d4406175085e60d08c"></a><!-- doxytag: member="MPU6050::setMotionDetectionCounterDecrement" ref="a74cc3ea727afa5d4406175085e60d08c" args="(uint8_t decrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setMotionDetectionCounterDecrement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>decrement</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Motion detection counter decrement configuration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">decrement</td><td>New decrement configuration value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a0ed8de8eb440dbfdec829297527b0da6">getMotionDetectionCounterDecrement()</a> </dd>
<dd>
MPU6050_RA_MOT_DETECT_CTRL </dd>
<dd>
MPU6050_DETECT_MOT_COUNT_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a6d81616aaa47539217057891c91ff08f"></a><!-- doxytag: member="MPU6050::setMotionDetectionDuration" ref="a6d81616aaa47539217057891c91ff08f" args="(uint8_t duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setMotionDetectionDuration </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set motion detection event duration threshold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">duration</td><td>New motion detection duration threshold value (LSB = 1ms) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8ba035c2ae4a05d7e51b0d29e4924fb0">getMotionDetectionDuration()</a> </dd>
<dd>
MPU6050_RA_MOT_DUR </dd></dl>

</div>
</div>
<a class="anchor" id="aa23c8d66502345c30915e69975fd2cc9"></a><!-- doxytag: member="MPU6050::setMotionDetectionThreshold" ref="aa23c8d66502345c30915e69975fd2cc9" args="(uint8_t threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setMotionDetectionThreshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set free-fall event acceleration threshold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">threshold</td><td>New motion detection acceleration threshold value (LSB = 2mg) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ab7a825b1b8b86cebda308289630795e7">getMotionDetectionThreshold()</a> </dd>
<dd>
MPU6050_RA_MOT_THR </dd></dl>

</div>
</div>
<a class="anchor" id="a039f5724974c5bf3f373ed9be031441c"></a><!-- doxytag: member="MPU6050::setMultiMasterEnabled" ref="a039f5724974c5bf3f373ed9be031441c" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setMultiMasterEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set multi-master enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New multi-master enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aa88483068837bd9bc9c9f6c59a7a79b7">getMultiMasterEnabled()</a> </dd>
<dd>
MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a7d03801d6b656e8e12cd3c1dd97824a8"></a><!-- doxytag: member="MPU6050::setRate" ref="a7d03801d6b656e8e12cd3c1dd97824a8" args="(uint8_t rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set gyroscope sample rate divider. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">rate</td><td>New sample rate divider </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a887a173e079980505763ffd1aa9fec05">getRate()</a> </dd>
<dd>
MPU6050_RA_SMPLRT_DIV </dd></dl>

</div>
</div>
<a class="anchor" id="a97fbf27e1b827f9dfc3c28ff376b54c4"></a><!-- doxytag: member="MPU6050::setSlave0FIFOEnabled" ref="a97fbf27e1b827f9dfc3c28ff376b54c4" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave0FIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Slave 0 FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New Slave 0 FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6aa7aa2e3fac06f8b5ab9ee127255a5e">getSlave0FIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a5d432fa2fb8b2227f50aa5c7b5befb66"></a><!-- doxytag: member="MPU6050::setSlave1FIFOEnabled" ref="a5d432fa2fb8b2227f50aa5c7b5befb66" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave1FIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Slave 1 FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New Slave 1 FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#afd6a9b55a589c83c9a0fb0b5b2a88234">getSlave1FIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a38a10ac4f30b96718ec021dc0db8587b"></a><!-- doxytag: member="MPU6050::setSlave2FIFOEnabled" ref="a38a10ac4f30b96718ec021dc0db8587b" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave2FIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Slave 2 FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New Slave 2 FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a3c2e29508607a655221a2fa4f4219b4d">getSlave2FIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a6ed713870c7f6d085ded91a45515a36c"></a><!-- doxytag: member="MPU6050::setSlave3FIFOEnabled" ref="a6ed713870c7f6d085ded91a45515a36c" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave3FIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Slave 3 FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New Slave 3 FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9d75ec63e2320ecfb84a2b082397f900">getSlave3FIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a6985da2cbc37be3fefbe3c16bf8d34a6"></a><!-- doxytag: member="MPU6050::setSlave4Address" ref="a6985da2cbc37be3fefbe3c16bf8d34a6" args="(uint8_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4Address </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the I2C address of Slave 4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">address</td><td>New address for Slave 4 </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4278dec5fec25be9a6f45b51a3373ad2">getSlave4Address()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_ADDR </dd></dl>

</div>
</div>
<a class="anchor" id="a04be2a8c3af6ef174f97769b9b5164a9"></a><!-- doxytag: member="MPU6050::setSlave4Enabled" ref="a04be2a8c3af6ef174f97769b9b5164a9" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4Enabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the enabled value for Slave 4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New enabled value for Slave 4 </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4b9e13d6776ba99e042773873557bedd">getSlave4Enabled()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7498ebc26f8a1fe8c9dcf40cd5d265"></a><!-- doxytag: member="MPU6050::setSlave4InterruptEnabled" ref="a7d7498ebc26f8a1fe8c9dcf40cd5d265" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4InterruptEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the enabled value for Slave 4 transaction interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New enabled value for Slave 4 transaction interrupts. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a051549bcfa2eeb848c8557fc3efe74da">getSlave4InterruptEnabled()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="ac154934a43c599cdc564fb29c22c45eb"></a><!-- doxytag: member="MPU6050::setSlave4MasterDelay" ref="ac154934a43c599cdc564fb29c22c45eb" args="(uint8_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4MasterDelay </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Slave 4 master delay value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">delay</td><td>New Slave 4 master delay value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a9a4585b3c9e61478db198011107a56a9">getSlave4MasterDelay()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a17147a6f477be79f58889e9e6329392f"></a><!-- doxytag: member="MPU6050::setSlave4OutputByte" ref="a17147a6f477be79f58889e9e6329392f" args="(uint8_t data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4OutputByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set new byte to write to Slave 4. This register stores the data to be
 written into the Slave 4. If I2C_SLV4_RW is set 1 (set to read), this 
register has no effect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">data</td><td>New byte to write to Slave 4 </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV4_DO </dd></dl>

</div>
</div>
<a class="anchor" id="ae54dc358da048e61a1ac68012300fdaa"></a><!-- doxytag: member="MPU6050::setSlave4Register" ref="ae54dc358da048e61a1ac68012300fdaa" args="(uint8_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4Register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the active internal register for Slave 4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">reg</td><td>New active register for Slave 4 </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a7bd548cb60ecceb27c72f026ec0a60f8">getSlave4Register()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_REG </dd></dl>

</div>
</div>
<a class="anchor" id="af1402fe7f3e1cc0dedb6714351cbca4e"></a><!-- doxytag: member="MPU6050::setSlave4WriteMode" ref="af1402fe7f3e1cc0dedb6714351cbca4e" args="(bool mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlave4WriteMode </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set write mode for the Slave 4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">mode</td><td>New write mode for Slave 4 (0 = register address + data, 1 = data only) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a8d5a5e73907c78960154b92656127372">getSlave4WriteMode()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV4_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a3c07eb2c59fff3ddc7186319ee40ba6f"></a><!-- doxytag: member="MPU6050::setSlaveAddress" ref="a3c07eb2c59fff3ddc7186319ee40ba6f" args="(uint8_t num, uint8_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>address</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the I2C address of the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">address</td><td>New address for specified slave </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#af75b9f7ccac48515c7544238db0e6863">getSlaveAddress()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_ADDR </dd></dl>

</div>
</div>
<a class="anchor" id="ab4151353f433c533246d938fc3b78458"></a><!-- doxytag: member="MPU6050::setSlaveDataLength" ref="ab4151353f433c533246d938fc3b78458" args="(uint8_t num, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveDataLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>length</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set number of bytes to read for the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to read for specified slave </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a54c2a48b3cb79106bcaf75accf6cd311">getSlaveDataLength()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a471929d7cf9049357c345633d22412a9"></a><!-- doxytag: member="MPU6050::setSlaveDelayEnabled" ref="a471929d7cf9049357c345633d22412a9" args="(uint8_t num, bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveDelayEnabled </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set slave delay enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-4) </td></tr>
    <tr><td class="paramname">enabled</td><td>New slave delay enabled status. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_MST_DELAY_CTRL </dd>
<dd>
MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="afaffa021d7bb41f3a288827080602eee"></a><!-- doxytag: member="MPU6050::setSlaveEnabled" ref="afaffa021d7bb41f3a288827080602eee" args="(uint8_t num, bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveEnabled </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the enabled value for the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">enabled</td><td>New enabled value for specified slave </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a5f14bde83fe00b27dec6776fc44e89c2">getSlaveEnabled()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a34a1def575f6abcd464afe954de8a461"></a><!-- doxytag: member="MPU6050::setSlaveOutputByte" ref="a34a1def575f6abcd464afe954de8a461" args="(uint8_t num, uint8_t data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveOutputByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>data</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Write byte to Data Output container for specified slave. This 
register holds the output data written into Slave when Slave is set to 
write mode. For further information regarding Slave control, please 
refer to Registers 37 to 39 and immediately following. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">data</td><td>Byte to write </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_I2C_SLV0_DO </dd></dl>

</div>
</div>
<a class="anchor" id="a3413efbf2f4e8a27aa8768d9bc34d663"></a><!-- doxytag: member="MPU6050::setSlaveReadWriteTransitionEnabled" ref="a3413efbf2f4e8a27aa8768d9bc34d663" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveReadWriteTransitionEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set slave read/write transition enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New slave read/write transition enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a6b3c3aab80fcaa384303f9df2a59d7eb">getSlaveReadWriteTransitionEnabled()</a> </dd>
<dd>
MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a62851e982059a2462d52c210ad764a1c"></a><!-- doxytag: member="MPU6050::setSlaveRegister" ref="a62851e982059a2462d52c210ad764a1c" args="(uint8_t num, uint8_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>reg</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set the active internal register for the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">reg</td><td>New active register for specified slave </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ae7e9ead9645bcef326eb579c6ab5d5ff">getSlaveRegister()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_REG </dd></dl>

</div>
</div>
<a class="anchor" id="abeb1f83652066d7543fd3283af794364"></a><!-- doxytag: member="MPU6050::setSlaveWordByteSwap" ref="abeb1f83652066d7543fd3283af794364" args="(uint8_t num, bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveWordByteSwap </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set word pair byte-swapping enabled for the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">enabled</td><td>New word pair byte-swapping enabled value for specified slave </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a18e8f3d053a68f0e5ecf497c87ecac8a">getSlaveWordByteSwap()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a32602ab86f70b70d3313628fc6c010ae"></a><!-- doxytag: member="MPU6050::setSlaveWordGroupOffset" ref="a32602ab86f70b70d3313628fc6c010ae" args="(uint8_t num, bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveWordGroupOffset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set word pair grouping order offset for the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">enabled</td><td>New word pair grouping order offset for specified slave </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a32ce8023bb80afc5d55811de70c7214f">getSlaveWordGroupOffset()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a3d9bfcb5394c7a382009cd2dc91ce801"></a><!-- doxytag: member="MPU6050::setSlaveWriteMode" ref="a3d9bfcb5394c7a382009cd2dc91ce801" args="(uint8_t num, bool mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSlaveWriteMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>mode</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set write mode for the specified slave (0-3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">num</td><td>Slave number (0-3) </td></tr>
    <tr><td class="paramname">mode</td><td>New write mode for specified slave (0 = register address + data, 1 = data only) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#adb99955fa66300b1f0bedfcdd8187412">getSlaveWriteMode()</a> </dd>
<dd>
MPU6050_RA_I2C_SLV0_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a15ec5f8e7daf235f507c1d8b96af051a"></a><!-- doxytag: member="MPU6050::setSleepEnabled" ref="a15ec5f8e7daf235f507c1d8b96af051a" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setSleepEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set sleep mode status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New sleep mode enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a196404ef04b959083d4bf5e6f1cd8b98">getSleepEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_SLEEP_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="af4df87fd2e87f41d06706cfd5bbc2a2c"></a><!-- doxytag: member="MPU6050::setStandbyXAccelEnabled" ref="af4df87fd2e87f41d06706cfd5bbc2a2c" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setStandbyXAccelEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set X-axis accelerometer standby enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">New</td><td>X-axis standby enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a99261a04739fdb7a9a1c5b67ce3e710e">getStandbyXAccelEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_XA_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ac1c6d8f623a9ca00a4ddc50f6615b977"></a><!-- doxytag: member="MPU6050::setStandbyXGyroEnabled" ref="ac1c6d8f623a9ca00a4ddc50f6615b977" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setStandbyXGyroEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set X-axis gyroscope standby enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">New</td><td>X-axis standby enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#acb5fde4167aa54fbbe84706d577a48a6">getStandbyXGyroEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_XG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a7ce7d3299479eb66518acf0697132835"></a><!-- doxytag: member="MPU6050::setStandbyYAccelEnabled" ref="a7ce7d3299479eb66518acf0697132835" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setStandbyYAccelEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Y-axis accelerometer standby enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">New</td><td>Y-axis standby enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a104f2ec438d745f8fdeec202bae09b48">getStandbyYAccelEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_YA_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ab0973d64b7132188539b07991f7ea1f0"></a><!-- doxytag: member="MPU6050::setStandbyYGyroEnabled" ref="ab0973d64b7132188539b07991f7ea1f0" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setStandbyYGyroEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Y-axis gyroscope standby enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">New</td><td>Y-axis standby enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#aaad2985f8d22aec123f1e1dabcdd427a">getStandbyYGyroEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_YG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ac5fd917549d2ed0f12b8a17167271199"></a><!-- doxytag: member="MPU6050::setStandbyZAccelEnabled" ref="ac5fd917549d2ed0f12b8a17167271199" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setStandbyZAccelEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Z-axis accelerometer standby enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">New</td><td>Z-axis standby enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#adae85612e047c4c7f0c3b7110fc92956">getStandbyZAccelEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_ZA_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ada7c8a873fe157703dcdc08e25b48e32"></a><!-- doxytag: member="MPU6050::setStandbyZGyroEnabled" ref="ada7c8a873fe157703dcdc08e25b48e32" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setStandbyZGyroEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set Z-axis gyroscope standby enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">New</td><td>Z-axis standby enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a20f7804db1a980a3c425ae44c33d420b">getStandbyZGyroEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_2 </dd>
<dd>
MPU6050_PWR2_STBY_ZG_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="ae528a25b4997ad0e3091a012e4e4419e"></a><!-- doxytag: member="MPU6050::setTempFIFOEnabled" ref="ae528a25b4997ad0e3091a012e4e4419e" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setTempFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set temperature FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New temperature FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a913c2095001e204b5b09f8382a86d2ca">getTempFIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a0113871802e88c80fe69ce1f607987ff"></a><!-- doxytag: member="MPU6050::setTempSensorEnabled" ref="a0113871802e88c80fe69ce1f607987ff" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setTempSensorEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set temperature sensor enabled status. Note: this register stores the
 *disabled* value, but for consistency with the rest of the code, the 
function is named and used with standard true/false values to indicate 
whether the sensor is enabled or disabled, respectively.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New temperature sensor enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a31f588beab6760258212c65725eba336">getTempSensorEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_TEMP_DIS_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a20dc4bdedbe1550580c28a6d090291be"></a><!-- doxytag: member="MPU6050::setWaitForExternalSensorEnabled" ref="a20dc4bdedbe1550580c28a6d090291be" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setWaitForExternalSensorEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set wait-for-external-sensor-data enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New wait-for-external-sensor-data enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a4e2ebda47b85b4c5463f041c790bf5c0">getWaitForExternalSensorEnabled()</a> </dd>
<dd>
MPU6050_RA_I2C_MST_CTRL </dd></dl>

</div>
</div>
<a class="anchor" id="a340eade71cf6286f6904c2021330944e"></a><!-- doxytag: member="MPU6050::setWakeCycleEnabled" ref="a340eade71cf6286f6904c2021330944e" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setWakeCycleEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set wake cycle enabled status. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New sleep mode enabled status </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a89afc5235b9088c696e2cc7841f5259a">getWakeCycleEnabled()</a> </dd>
<dd>
MPU6050_RA_PWR_MGMT_1 </dd>
<dd>
MPU6050_PWR1_CYCLE_BIT </dd></dl>

</div>
</div>
<a class="anchor" id="a62495e89f4787e6b18f0f795cef2b7cd"></a><!-- doxytag: member="MPU6050::setWakeFrequency" ref="a62495e89f4787e6b18f0f795cef2b7cd" args="(uint8_t frequency)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setWakeFrequency </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set wake frequency in Accel-Only Low Power Mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">frequency</td><td>New wake frequency </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>MPU6050_RA_PWR_MGMT_2 </dd></dl>

</div>
</div>
<a class="anchor" id="a53a03d1f255a62f01375c870cdc85767"></a><!-- doxytag: member="MPU6050::setXGyroFIFOEnabled" ref="a53a03d1f255a62f01375c870cdc85767" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setXGyroFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set gyroscope X-axis FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New gyroscope X-axis FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ada9a553176b57815f23fb7d71bb85c9d">getXGyroFIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a16eb12bbf07bc17a9d852941d834175e"></a><!-- doxytag: member="MPU6050::setYGyroFIFOEnabled" ref="a16eb12bbf07bc17a9d852941d834175e" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setYGyroFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set gyroscope Y-axis FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New gyroscope Y-axis FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a86c85d5b5c93df82394435b868e17463">getYGyroFIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a6d25a21e1673682f096399b719c66d2c"></a><!-- doxytag: member="MPU6050::setZeroMotionDetectionDuration" ref="a6d25a21e1673682f096399b719c66d2c" args="(uint8_t duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setZeroMotionDetectionDuration </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set zero motion detection event duration threshold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">duration</td><td>New zero motion detection duration threshold value (LSB = 1ms) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#a04c0fcdcd0157b6dbf74d4901424801e">getZeroMotionDetectionDuration()</a> </dd>
<dd>
MPU6050_RA_ZRMOT_DUR </dd></dl>

</div>
</div>
<a class="anchor" id="a347a51fd25de20b9ead4659015ef793b"></a><!-- doxytag: member="MPU6050::setZeroMotionDetectionThreshold" ref="a347a51fd25de20b9ead4659015ef793b" args="(uint8_t threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setZeroMotionDetectionThreshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set zero motion detection event acceleration threshold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">threshold</td><td>New zero motion detection acceleration threshold value (LSB = 2mg) </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#ad941c1e844dc9230675c115734599ea3">getZeroMotionDetectionThreshold()</a> </dd>
<dd>
MPU6050_RA_ZRMOT_THR </dd></dl>

</div>
</div>
<a class="anchor" id="af5b5bc39b66466ba910f6eef1259444c"></a><!-- doxytag: member="MPU6050::setZGyroFIFOEnabled" ref="af5b5bc39b66466ba910f6eef1259444c" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::setZGyroFIFOEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Set gyroscope Z-axis FIFO enabled value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">enabled</td><td>New gyroscope Z-axis FIFO enabled value </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http://www.i2cdevlib.com/docs/html/class_m_p_u6050.html#adbbbd131c74f37dd545403633eb317ff">getZGyroFIFOEnabled()</a> </dd>
<dd>
MPU6050_RA_FIFO_EN </dd></dl>

</div>
</div>
<a class="anchor" id="a269710b7bca814bbf67e7bb38c381650"></a><!-- doxytag: member="MPU6050::switchSPIEnabled" ref="a269710b7bca814bbf67e7bb38c381650" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void MPU6050::switchSPIEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Switch from I2C to SPI mode (MPU-6000 only) If this is set, the 
primary SPI interface will be enabled in place of the disabled primary 
I2C interface. </p>

</div>
</div>
<a class="anchor" id="a95ffab7b44fce3834236e0813687d11a"></a><!-- doxytag: member="MPU6050::testConnection" ref="a95ffab7b44fce3834236e0813687d11a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool MPU6050::testConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
</div>
<div class="memdoc">
<p>Verify the I2C connection. Make sure the device is connected and responds as expected. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if connection is valid, false otherwise </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MPU6050/<a class="el" href="http://www.i2cdevlib.com/docs/html/_m_p_u6050_8h_source.html">MPU6050.h</a></li>
<li>MPU6050/MPU6050.cpp</li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark"></span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" name="MSearchResults" id="MSearchResults" frameborder="0">
</iframe>
</div>



<hr class="footer"><address class="footer"><small>
Generated on Sun Nov 13 2011 21:37:30 for I2Cdevlib by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/doxygen.png" alt="doxygen"></a> 1.7.4</small></address>

<script type="text/javascript">

var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");

document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));

</script><script src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/ga.js" type="text/javascript"></script>

<script type="text/javascript">

try{ 

var pageTracker = _gat._getTracker("UA-10986936-22");

pageTracker._trackPageview();

} catch(err) {} 

</script><script type="text/javascript" src="I2Cdevlib%20%20MPU6050%20Class%20Reference-Dateien/woopra.js"></script>

<script type="text/javascript">

woopraTracker.track();

</script>

</body></html>